var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  __markAsModule(target);
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
};

// node_modules/vscode-jsonrpc/lib/is.js
var require_is = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function boolean2(value) {
    return value === true || value === false;
  }
  exports2.boolean = boolean2;
  function string2(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports2.string = string2;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports2.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports2.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports2.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports2.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string2(elem));
  }
  exports2.stringArray = stringArray;
});

// node_modules/vscode-jsonrpc/lib/messages.js
var require_messages = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var is2 = require_is();
  var ErrorCodes;
  (function(ErrorCodes2) {
    ErrorCodes2.ParseError = -32700;
    ErrorCodes2.InvalidRequest = -32600;
    ErrorCodes2.MethodNotFound = -32601;
    ErrorCodes2.InvalidParams = -32602;
    ErrorCodes2.InternalError = -32603;
    ErrorCodes2.serverErrorStart = -32099;
    ErrorCodes2.serverErrorEnd = -32e3;
    ErrorCodes2.ServerNotInitialized = -32002;
    ErrorCodes2.UnknownErrorCode = -32001;
    ErrorCodes2.RequestCancelled = -32800;
    ErrorCodes2.ContentModified = -32801;
    ErrorCodes2.MessageWriteError = 1;
    ErrorCodes2.MessageReadError = 2;
  })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
  var ResponseError = class extends Error {
    constructor(code, message, data) {
      super(message);
      this.code = is2.number(code) ? code : ErrorCodes.UnknownErrorCode;
      this.data = data;
      Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
      return {
        code: this.code,
        message: this.message,
        data: this.data
      };
    }
  };
  exports2.ResponseError = ResponseError;
  var AbstractMessageType = class {
    constructor(_method, _numberOfParams) {
      this._method = _method;
      this._numberOfParams = _numberOfParams;
    }
    get method() {
      return this._method;
    }
    get numberOfParams() {
      return this._numberOfParams;
    }
  };
  exports2.AbstractMessageType = AbstractMessageType;
  var RequestType0 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.RequestType0 = RequestType0;
  var RequestType = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
    }
  };
  exports2.RequestType = RequestType;
  var RequestType1 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
    }
  };
  exports2.RequestType1 = RequestType1;
  var RequestType2 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.RequestType2 = RequestType2;
  var RequestType3 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.RequestType3 = RequestType3;
  var RequestType4 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.RequestType4 = RequestType4;
  var RequestType5 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.RequestType5 = RequestType5;
  var RequestType6 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.RequestType6 = RequestType6;
  var RequestType7 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.RequestType7 = RequestType7;
  var RequestType8 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.RequestType8 = RequestType8;
  var RequestType9 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.RequestType9 = RequestType9;
  var NotificationType = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
      this._ = void 0;
    }
  };
  exports2.NotificationType = NotificationType;
  var NotificationType0 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 0);
    }
  };
  exports2.NotificationType0 = NotificationType0;
  var NotificationType1 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 1);
    }
  };
  exports2.NotificationType1 = NotificationType1;
  var NotificationType2 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 2);
    }
  };
  exports2.NotificationType2 = NotificationType2;
  var NotificationType3 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 3);
    }
  };
  exports2.NotificationType3 = NotificationType3;
  var NotificationType4 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 4);
    }
  };
  exports2.NotificationType4 = NotificationType4;
  var NotificationType5 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 5);
    }
  };
  exports2.NotificationType5 = NotificationType5;
  var NotificationType6 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 6);
    }
  };
  exports2.NotificationType6 = NotificationType6;
  var NotificationType7 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 7);
    }
  };
  exports2.NotificationType7 = NotificationType7;
  var NotificationType8 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 8);
    }
  };
  exports2.NotificationType8 = NotificationType8;
  var NotificationType9 = class extends AbstractMessageType {
    constructor(method) {
      super(method, 9);
    }
  };
  exports2.NotificationType9 = NotificationType9;
  function isRequestMessage(message) {
    let candidate = message;
    return candidate && is2.string(candidate.method) && (is2.string(candidate.id) || is2.number(candidate.id));
  }
  exports2.isRequestMessage = isRequestMessage;
  function isNotificationMessage(message) {
    let candidate = message;
    return candidate && is2.string(candidate.method) && message.id === void 0;
  }
  exports2.isNotificationMessage = isNotificationMessage;
  function isResponseMessage(message) {
    let candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is2.string(candidate.id) || is2.number(candidate.id) || candidate.id === null);
  }
  exports2.isResponseMessage = isResponseMessage;
});

// node_modules/vscode-jsonrpc/lib/events.js
var require_events = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Disposable13;
  (function(Disposable14) {
    function create(func) {
      return {
        dispose: func
      };
    }
    Disposable14.create = create;
  })(Disposable13 = exports2.Disposable || (exports2.Disposable = {}));
  var Event5;
  (function(Event6) {
    const _disposable = {dispose() {
    }};
    Event6.None = function() {
      return _disposable;
    };
  })(Event5 = exports2.Event || (exports2.Event = {}));
  var CallbackList = class {
    add(callback, context = null, bucket) {
      if (!this._callbacks) {
        this._callbacks = [];
        this._contexts = [];
      }
      this._callbacks.push(callback);
      this._contexts.push(context);
      if (Array.isArray(bucket)) {
        bucket.push({dispose: () => this.remove(callback, context)});
      }
    }
    remove(callback, context = null) {
      if (!this._callbacks) {
        return;
      }
      var foundCallbackWithDifferentContext = false;
      for (var i = 0, len = this._callbacks.length; i < len; i++) {
        if (this._callbacks[i] === callback) {
          if (this._contexts[i] === context) {
            this._callbacks.splice(i, 1);
            this._contexts.splice(i, 1);
            return;
          } else {
            foundCallbackWithDifferentContext = true;
          }
        }
      }
      if (foundCallbackWithDifferentContext) {
        throw new Error("When adding a listener with a context, you should remove it with the same context");
      }
    }
    invoke(...args) {
      if (!this._callbacks) {
        return [];
      }
      var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
      for (var i = 0, len = callbacks.length; i < len; i++) {
        try {
          ret.push(callbacks[i].apply(contexts[i], args));
        } catch (e) {
          console.error(e);
        }
      }
      return ret;
    }
    isEmpty() {
      return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
      this._callbacks = void 0;
      this._contexts = void 0;
    }
  };
  var Emitter6 = class {
    constructor(_options) {
      this._options = _options;
    }
    get event() {
      if (!this._event) {
        this._event = (listener, thisArgs, disposables) => {
          if (!this._callbacks) {
            this._callbacks = new CallbackList();
          }
          if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
            this._options.onFirstListenerAdd(this);
          }
          this._callbacks.add(listener, thisArgs);
          let result;
          result = {
            dispose: () => {
              this._callbacks.remove(listener, thisArgs);
              result.dispose = Emitter6._noop;
              if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                this._options.onLastListenerRemove(this);
              }
            }
          };
          if (Array.isArray(disposables)) {
            disposables.push(result);
          }
          return result;
        };
      }
      return this._event;
    }
    fire(event) {
      if (this._callbacks) {
        this._callbacks.invoke.call(this._callbacks, event);
      }
    }
    dispose() {
      if (this._callbacks) {
        this._callbacks.dispose();
        this._callbacks = void 0;
      }
    }
  };
  exports2.Emitter = Emitter6;
  Emitter6._noop = function() {
  };
});

// node_modules/vscode-jsonrpc/lib/messageReader.js
var require_messageReader = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require_events();
  var Is = require_is();
  var DefaultSize2 = 8192;
  var CR = Buffer.from("\r", "ascii")[0];
  var LF = Buffer.from("\n", "ascii")[0];
  var CRLF = "\r\n";
  var MessageBuffer = class {
    constructor(encoding = "utf8") {
      this.encoding = encoding;
      this.index = 0;
      this.buffer = Buffer.allocUnsafe(DefaultSize2);
    }
    append(chunk) {
      var toAppend = chunk;
      if (typeof chunk === "string") {
        var str = chunk;
        var bufferLen = Buffer.byteLength(str, this.encoding);
        toAppend = Buffer.allocUnsafe(bufferLen);
        toAppend.write(str, 0, bufferLen, this.encoding);
      }
      if (this.buffer.length - this.index >= toAppend.length) {
        toAppend.copy(this.buffer, this.index, 0, toAppend.length);
      } else {
        var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize2) + 1) * DefaultSize2;
        if (this.index === 0) {
          this.buffer = Buffer.allocUnsafe(newSize);
          toAppend.copy(this.buffer, 0, 0, toAppend.length);
        } else {
          this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
        }
      }
      this.index += toAppend.length;
    }
    tryReadHeaders() {
      let result = void 0;
      let current = 0;
      while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
        current++;
      }
      if (current + 3 >= this.index) {
        return result;
      }
      result = Object.create(null);
      let headers = this.buffer.toString("ascii", 0, current).split(CRLF);
      headers.forEach((header) => {
        let index = header.indexOf(":");
        if (index === -1) {
          throw new Error("Message header must separate key and value using :");
        }
        let key = header.substr(0, index);
        let value = header.substr(index + 1).trim();
        result[key] = value;
      });
      let nextStart = current + 4;
      this.buffer = this.buffer.slice(nextStart);
      this.index = this.index - nextStart;
      return result;
    }
    tryReadContent(length) {
      if (this.index < length) {
        return null;
      }
      let result = this.buffer.toString(this.encoding, 0, length);
      let nextStart = length;
      this.buffer.copy(this.buffer, 0, nextStart);
      this.index = this.index - nextStart;
      return result;
    }
    get numberOfBytes() {
      return this.index;
    }
  };
  var MessageReader;
  (function(MessageReader2) {
    function is2(value) {
      let candidate = value;
      return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader2.is = is2;
  })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
  var AbstractMessageReader = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
      this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error) {
      this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    get onPartialMessage() {
      return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
      this.partialMessageEmitter.fire(info);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageReader = AbstractMessageReader;
  var StreamMessageReader = class extends AbstractMessageReader {
    constructor(readable, encoding = "utf8") {
      super();
      this.readable = readable;
      this.buffer = new MessageBuffer(encoding);
      this._partialMessageTimeout = 1e4;
    }
    set partialMessageTimeout(timeout) {
      this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
      return this._partialMessageTimeout;
    }
    listen(callback) {
      this.nextMessageLength = -1;
      this.messageToken = 0;
      this.partialMessageTimer = void 0;
      this.callback = callback;
      this.readable.on("data", (data) => {
        this.onData(data);
      });
      this.readable.on("error", (error) => this.fireError(error));
      this.readable.on("close", () => this.fireClose());
    }
    onData(data) {
      this.buffer.append(data);
      while (true) {
        if (this.nextMessageLength === -1) {
          let headers = this.buffer.tryReadHeaders();
          if (!headers) {
            return;
          }
          let contentLength = headers["Content-Length"];
          if (!contentLength) {
            throw new Error("Header must provide a Content-Length property.");
          }
          let length = parseInt(contentLength);
          if (isNaN(length)) {
            throw new Error("Content-Length value must be a number.");
          }
          this.nextMessageLength = length;
        }
        var msg = this.buffer.tryReadContent(this.nextMessageLength);
        if (msg === null) {
          this.setPartialMessageTimer();
          return;
        }
        this.clearPartialMessageTimer();
        this.nextMessageLength = -1;
        this.messageToken++;
        var json = JSON.parse(msg);
        this.callback(json);
      }
    }
    clearPartialMessageTimer() {
      if (this.partialMessageTimer) {
        clearTimeout(this.partialMessageTimer);
        this.partialMessageTimer = void 0;
      }
    }
    setPartialMessageTimer() {
      this.clearPartialMessageTimer();
      if (this._partialMessageTimeout <= 0) {
        return;
      }
      this.partialMessageTimer = setTimeout((token, timeout) => {
        this.partialMessageTimer = void 0;
        if (token === this.messageToken) {
          this.firePartialMessage({messageToken: token, waitingTime: timeout});
          this.setPartialMessageTimer();
        }
      }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
  };
  exports2.StreamMessageReader = StreamMessageReader;
  var IPCMessageReader = class extends AbstractMessageReader {
    constructor(process2) {
      super();
      this.process = process2;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose());
    }
    listen(callback) {
      this.process.on("message", callback);
    }
  };
  exports2.IPCMessageReader = IPCMessageReader;
  var SocketMessageReader = class extends StreamMessageReader {
    constructor(socket, encoding = "utf-8") {
      super(socket, encoding);
    }
  };
  exports2.SocketMessageReader = SocketMessageReader;
});

// node_modules/vscode-jsonrpc/lib/messageWriter.js
var require_messageWriter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require_events();
  var Is = require_is();
  var ContentLength2 = "Content-Length: ";
  var CRLF = "\r\n";
  var MessageWriter;
  (function(MessageWriter2) {
    function is2(value) {
      let candidate = value;
      return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter2.is = is2;
  })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
  var AbstractMessageWriter = class {
    constructor() {
      this.errorEmitter = new events_1.Emitter();
      this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error, message, count) {
      this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(void 0);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  };
  exports2.AbstractMessageWriter = AbstractMessageWriter;
  var StreamMessageWriter = class extends AbstractMessageWriter {
    constructor(writable, encoding = "utf8") {
      super();
      this.writable = writable;
      this.encoding = encoding;
      this.errorCount = 0;
      this.writable.on("error", (error) => this.fireError(error));
      this.writable.on("close", () => this.fireClose());
    }
    write(msg) {
      let json = JSON.stringify(msg);
      let contentLength = Buffer.byteLength(json, this.encoding);
      let headers = [
        ContentLength2,
        contentLength.toString(),
        CRLF,
        CRLF
      ];
      try {
        this.writable.write(headers.join(""), "ascii");
        this.writable.write(json, this.encoding);
        this.errorCount = 0;
      } catch (error) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
    }
  };
  exports2.StreamMessageWriter = StreamMessageWriter;
  var IPCMessageWriter = class extends AbstractMessageWriter {
    constructor(process2) {
      super();
      this.process = process2;
      this.errorCount = 0;
      this.queue = [];
      this.sending = false;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose);
    }
    write(msg) {
      if (!this.sending && this.queue.length === 0) {
        this.doWriteMessage(msg);
      } else {
        this.queue.push(msg);
      }
    }
    doWriteMessage(msg) {
      try {
        if (this.process.send) {
          this.sending = true;
          this.process.send(msg, void 0, void 0, (error) => {
            this.sending = false;
            if (error) {
              this.errorCount++;
              this.fireError(error, msg, this.errorCount);
            } else {
              this.errorCount = 0;
            }
            if (this.queue.length > 0) {
              this.doWriteMessage(this.queue.shift());
            }
          });
        }
      } catch (error) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
    }
  };
  exports2.IPCMessageWriter = IPCMessageWriter;
  var SocketMessageWriter = class extends AbstractMessageWriter {
    constructor(socket, encoding = "utf8") {
      super();
      this.socket = socket;
      this.queue = [];
      this.sending = false;
      this.encoding = encoding;
      this.errorCount = 0;
      this.socket.on("error", (error) => this.fireError(error));
      this.socket.on("close", () => this.fireClose());
    }
    dispose() {
      super.dispose();
      this.socket.destroy();
    }
    write(msg) {
      if (!this.sending && this.queue.length === 0) {
        this.doWriteMessage(msg);
      } else {
        this.queue.push(msg);
      }
    }
    doWriteMessage(msg) {
      let json = JSON.stringify(msg);
      let contentLength = Buffer.byteLength(json, this.encoding);
      let headers = [
        ContentLength2,
        contentLength.toString(),
        CRLF,
        CRLF
      ];
      try {
        this.sending = true;
        this.socket.write(headers.join(""), "ascii", (error) => {
          if (error) {
            this.handleError(error, msg);
          }
          try {
            this.socket.write(json, this.encoding, (error2) => {
              this.sending = false;
              if (error2) {
                this.handleError(error2, msg);
              } else {
                this.errorCount = 0;
              }
              if (this.queue.length > 0) {
                this.doWriteMessage(this.queue.shift());
              }
            });
          } catch (error2) {
            this.handleError(error2, msg);
          }
        });
      } catch (error) {
        this.handleError(error, msg);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
  };
  exports2.SocketMessageWriter = SocketMessageWriter;
});

// node_modules/vscode-jsonrpc/lib/cancellation.js
var require_cancellation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var events_1 = require_events();
  var Is = require_is();
  var CancellationToken19;
  (function(CancellationToken20) {
    CancellationToken20.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: events_1.Event.None
    });
    CancellationToken20.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: events_1.Event.None
    });
    function is2(value) {
      let candidate = value;
      return candidate && (candidate === CancellationToken20.None || candidate === CancellationToken20.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
    }
    CancellationToken20.is = is2;
  })(CancellationToken19 = exports2.CancellationToken || (exports2.CancellationToken = {}));
  var shortcutEvent = Object.freeze(function(callback, context) {
    let handle = setTimeout(callback.bind(context), 0);
    return {dispose() {
      clearTimeout(handle);
    }};
  });
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new events_1.Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = void 0;
      }
    }
  };
  var CancellationTokenSource4 = class {
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken19.Cancelled;
      } else {
        this._token.cancel();
      }
    }
    dispose() {
      if (!this._token) {
        this._token = CancellationToken19.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };
  exports2.CancellationTokenSource = CancellationTokenSource4;
});

// node_modules/vscode-jsonrpc/lib/linkedMap.js
var require_linkedMap = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Touch;
  (function(Touch2) {
    Touch2.None = 0;
    Touch2.First = 1;
    Touch2.Last = 2;
  })(Touch = exports2.Touch || (exports2.Touch = {}));
  var LinkedMap = class {
    constructor() {
      this._map = new Map();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    clear() {
      this._map.clear();
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key) {
      const item = this._map.get(key);
      if (!item) {
        return void 0;
      }
      return item.value;
    }
    set(key, value, touch = Touch.None) {
      let item = this._map.get(key);
      if (item) {
        item.value = value;
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
      } else {
        item = {key, value, next: void 0, previous: void 0};
        switch (touch) {
          case Touch.None:
            this.addItemLast(item);
            break;
          case Touch.First:
            this.addItemFirst(item);
            break;
          case Touch.Last:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
    }
    delete(key) {
      const item = this._map.get(key);
      if (!item) {
        return false;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return true;
    }
    shift() {
      if (!this._head && !this._tail) {
        return void 0;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      let current = this._head;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        current = current.next;
      }
    }
    forEachReverse(callbackfn, thisArg) {
      let current = this._tail;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        current = current.previous;
      }
    }
    values() {
      let result = [];
      let current = this._head;
      while (current) {
        result.push(current.value);
        current = current.next;
      }
      return result;
    }
    keys() {
      let result = [];
      let current = this._head;
      while (current) {
        result.push(current.key);
        current = current.next;
      }
      return result;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = void 0;
        this._tail = void 0;
      } else if (item === this._head) {
        this._head = item.next;
      } else if (item === this._tail) {
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous = item.previous;
        if (!next || !previous) {
          throw new Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== Touch.First && touch !== Touch.Last) {
        return;
      }
      if (touch === Touch.First) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._tail) {
          previous.next = void 0;
          this._tail = previous;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.previous = void 0;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
      } else if (touch === Touch.Last) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._head) {
          next.previous = void 0;
          this._head = next;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
      }
    }
  };
  exports2.LinkedMap = LinkedMap;
});

// node_modules/vscode-jsonrpc/lib/pipeSupport.js
var require_pipeSupport = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var path_1 = require("path");
  var os_1 = require("os");
  var crypto_1 = require("crypto");
  var net_1 = require("net");
  var messageReader_1 = require_messageReader();
  var messageWriter_1 = require_messageWriter();
  function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString("hex");
    if (process.platform === "win32") {
      return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    } else {
      return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
  }
  exports2.generateRandomPipeName = generateRandomPipeName;
  function createClientPipeTransport(pipeName, encoding = "utf-8") {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      let server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new messageReader_1.SocketMessageReader(socket, encoding),
          new messageWriter_1.SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(pipeName, () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientPipeTransport = createClientPipeTransport;
  function createServerPipeTransport(pipeName, encoding = "utf-8") {
    const socket = net_1.createConnection(pipeName);
    return [
      new messageReader_1.SocketMessageReader(socket, encoding),
      new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerPipeTransport = createServerPipeTransport;
});

// node_modules/vscode-jsonrpc/lib/socketSupport.js
var require_socketSupport = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = require("net");
  var messageReader_1 = require_messageReader();
  var messageWriter_1 = require_messageWriter();
  function createClientSocketTransport(port, encoding = "utf-8") {
    let connectResolve;
    let connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      let server = net_1.createServer((socket) => {
        server.close();
        connectResolve([
          new messageReader_1.SocketMessageReader(socket, encoding),
          new messageWriter_1.SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(port, "127.0.0.1", () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports2.createClientSocketTransport = createClientSocketTransport;
  function createServerSocketTransport(port, encoding = "utf-8") {
    const socket = net_1.createConnection(port, "127.0.0.1");
    return [
      new messageReader_1.SocketMessageReader(socket, encoding),
      new messageWriter_1.SocketMessageWriter(socket, encoding)
    ];
  }
  exports2.createServerSocketTransport = createServerSocketTransport;
});

// node_modules/vscode-jsonrpc/lib/main.js
var require_main = __commonJS((exports2) => {
  "use strict";
  function __export2(m) {
    for (var p in m)
      if (!exports2.hasOwnProperty(p))
        exports2[p] = m[p];
  }
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Is = require_is();
  var messages_1 = require_messages();
  exports2.RequestType = messages_1.RequestType;
  exports2.RequestType0 = messages_1.RequestType0;
  exports2.RequestType1 = messages_1.RequestType1;
  exports2.RequestType2 = messages_1.RequestType2;
  exports2.RequestType3 = messages_1.RequestType3;
  exports2.RequestType4 = messages_1.RequestType4;
  exports2.RequestType5 = messages_1.RequestType5;
  exports2.RequestType6 = messages_1.RequestType6;
  exports2.RequestType7 = messages_1.RequestType7;
  exports2.RequestType8 = messages_1.RequestType8;
  exports2.RequestType9 = messages_1.RequestType9;
  exports2.ResponseError = messages_1.ResponseError;
  exports2.ErrorCodes = messages_1.ErrorCodes;
  exports2.NotificationType = messages_1.NotificationType;
  exports2.NotificationType0 = messages_1.NotificationType0;
  exports2.NotificationType1 = messages_1.NotificationType1;
  exports2.NotificationType2 = messages_1.NotificationType2;
  exports2.NotificationType3 = messages_1.NotificationType3;
  exports2.NotificationType4 = messages_1.NotificationType4;
  exports2.NotificationType5 = messages_1.NotificationType5;
  exports2.NotificationType6 = messages_1.NotificationType6;
  exports2.NotificationType7 = messages_1.NotificationType7;
  exports2.NotificationType8 = messages_1.NotificationType8;
  exports2.NotificationType9 = messages_1.NotificationType9;
  var messageReader_1 = require_messageReader();
  exports2.MessageReader = messageReader_1.MessageReader;
  exports2.StreamMessageReader = messageReader_1.StreamMessageReader;
  exports2.IPCMessageReader = messageReader_1.IPCMessageReader;
  exports2.SocketMessageReader = messageReader_1.SocketMessageReader;
  var messageWriter_1 = require_messageWriter();
  exports2.MessageWriter = messageWriter_1.MessageWriter;
  exports2.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
  exports2.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
  exports2.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
  var events_1 = require_events();
  exports2.Disposable = events_1.Disposable;
  exports2.Event = events_1.Event;
  exports2.Emitter = events_1.Emitter;
  var cancellation_1 = require_cancellation();
  exports2.CancellationTokenSource = cancellation_1.CancellationTokenSource;
  exports2.CancellationToken = cancellation_1.CancellationToken;
  var linkedMap_1 = require_linkedMap();
  __export2(require_pipeSupport());
  __export2(require_socketSupport());
  var CancelNotification;
  (function(CancelNotification2) {
    CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
  })(CancelNotification || (CancelNotification = {}));
  var ProgressNotification;
  (function(ProgressNotification2) {
    ProgressNotification2.type = new messages_1.NotificationType("$/progress");
  })(ProgressNotification || (ProgressNotification = {}));
  var ProgressType = class {
    constructor() {
    }
  };
  exports2.ProgressType = ProgressType;
  exports2.NullLogger = Object.freeze({
    error: () => {
    },
    warn: () => {
    },
    info: () => {
    },
    log: () => {
    }
  });
  var Trace2;
  (function(Trace3) {
    Trace3[Trace3["Off"] = 0] = "Off";
    Trace3[Trace3["Messages"] = 1] = "Messages";
    Trace3[Trace3["Verbose"] = 2] = "Verbose";
  })(Trace2 = exports2.Trace || (exports2.Trace = {}));
  (function(Trace3) {
    function fromString(value) {
      if (!Is.string(value)) {
        return Trace3.Off;
      }
      value = value.toLowerCase();
      switch (value) {
        case "off":
          return Trace3.Off;
        case "messages":
          return Trace3.Messages;
        case "verbose":
          return Trace3.Verbose;
        default:
          return Trace3.Off;
      }
    }
    Trace3.fromString = fromString;
    function toString2(value) {
      switch (value) {
        case Trace3.Off:
          return "off";
        case Trace3.Messages:
          return "messages";
        case Trace3.Verbose:
          return "verbose";
        default:
          return "off";
      }
    }
    Trace3.toString = toString2;
  })(Trace2 = exports2.Trace || (exports2.Trace = {}));
  var TraceFormat;
  (function(TraceFormat2) {
    TraceFormat2["Text"] = "text";
    TraceFormat2["JSON"] = "json";
  })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
  (function(TraceFormat2) {
    function fromString(value) {
      value = value.toLowerCase();
      if (value === "json") {
        return TraceFormat2.JSON;
      } else {
        return TraceFormat2.Text;
      }
    }
    TraceFormat2.fromString = fromString;
  })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
  var SetTraceNotification;
  (function(SetTraceNotification2) {
    SetTraceNotification2.type = new messages_1.NotificationType("$/setTraceNotification");
  })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
  var LogTraceNotification;
  (function(LogTraceNotification2) {
    LogTraceNotification2.type = new messages_1.NotificationType("$/logTraceNotification");
  })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
  var ConnectionErrors;
  (function(ConnectionErrors2) {
    ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
    ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
    ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
  })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
  var ConnectionError = class extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
      Object.setPrototypeOf(this, ConnectionError.prototype);
    }
  };
  exports2.ConnectionError = ConnectionError;
  var ConnectionStrategy;
  (function(ConnectionStrategy2) {
    function is2(value) {
      let candidate = value;
      return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy2.is = is2;
  })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2[ConnectionState2["New"] = 1] = "New";
    ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
    ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
    ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
  })(ConnectionState || (ConnectionState = {}));
  function _createMessageConnection(messageReader, messageWriter, logger, strategy) {
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = "2.0";
    let starRequestHandler = void 0;
    let requestHandlers = Object.create(null);
    let starNotificationHandler = void 0;
    let notificationHandlers = Object.create(null);
    let progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace2.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    let errorEmitter = new events_1.Emitter();
    let closeEmitter = new events_1.Emitter();
    let unhandledNotificationEmitter = new events_1.Emitter();
    let unhandledProgressEmitter = new events_1.Emitter();
    let disposeEmitter = new events_1.Emitter();
    function createRequestQueueKey(id) {
      return "req-" + id.toString();
    }
    function createResponseQueueKey(id) {
      if (id === null) {
        return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
      } else {
        return "res-" + id.toString();
      }
    }
    function createNotificationQueueKey() {
      return "not-" + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
      if (messages_1.isRequestMessage(message)) {
        queue.set(createRequestQueueKey(message.id), message);
      } else if (messages_1.isResponseMessage(message)) {
        queue.set(createResponseQueueKey(message.id), message);
      } else {
        queue.set(createNotificationQueueKey(), message);
      }
    }
    function cancelUndispatched(_message) {
      return void 0;
    }
    function isListening() {
      return state === ConnectionState.Listening;
    }
    function isClosed() {
      return state === ConnectionState.Closed;
    }
    function isDisposed() {
      return state === ConnectionState.Disposed;
    }
    function closeHandler() {
      if (state === ConnectionState.New || state === ConnectionState.Listening) {
        state = ConnectionState.Closed;
        closeEmitter.fire(void 0);
      }
    }
    function readErrorHandler(error) {
      errorEmitter.fire([error, void 0, void 0]);
    }
    function writeErrorHandler(data) {
      errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
      if (timer || messageQueue.size === 0) {
        return;
      }
      timer = setImmediate(() => {
        timer = void 0;
        processMessageQueue();
      });
    }
    function processMessageQueue() {
      if (messageQueue.size === 0) {
        return;
      }
      let message = messageQueue.shift();
      try {
        if (messages_1.isRequestMessage(message)) {
          handleRequest(message);
        } else if (messages_1.isNotificationMessage(message)) {
          handleNotification(message);
        } else if (messages_1.isResponseMessage(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      } finally {
        triggerMessageQueue();
      }
    }
    let callback = (message) => {
      try {
        if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
          let key = createRequestQueueKey(message.params.id);
          let toCancel = messageQueue.get(key);
          if (messages_1.isRequestMessage(toCancel)) {
            let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
            if (response && (response.error !== void 0 || response.result !== void 0)) {
              messageQueue.delete(key);
              response.id = toCancel.id;
              traceSendingResponse(response, message.method, Date.now());
              messageWriter.write(response);
              return;
            }
          }
        }
        addMessageToQueue(messageQueue, message);
      } finally {
        triggerMessageQueue();
      }
    };
    function handleRequest(requestMessage) {
      if (isDisposed()) {
        return;
      }
      function reply(resultOrError, method, startTime2) {
        let message = {
          jsonrpc: version,
          id: requestMessage.id
        };
        if (resultOrError instanceof messages_1.ResponseError) {
          message.error = resultOrError.toJson();
        } else {
          message.result = resultOrError === void 0 ? null : resultOrError;
        }
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message);
      }
      function replyError(error, method, startTime2) {
        let message = {
          jsonrpc: version,
          id: requestMessage.id,
          error: error.toJson()
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message);
      }
      function replySuccess(result, method, startTime2) {
        if (result === void 0) {
          result = null;
        }
        let message = {
          jsonrpc: version,
          id: requestMessage.id,
          result
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message);
      }
      traceReceivedRequest(requestMessage);
      let element = requestHandlers[requestMessage.method];
      let type;
      let requestHandler;
      if (element) {
        type = element.type;
        requestHandler = element.handler;
      }
      let startTime = Date.now();
      if (requestHandler || starRequestHandler) {
        let cancellationSource = new cancellation_1.CancellationTokenSource();
        let tokenKey = String(requestMessage.id);
        requestTokens[tokenKey] = cancellationSource;
        try {
          let handlerResult;
          if (requestMessage.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
            handlerResult = requestHandler ? requestHandler(cancellationSource.token) : starRequestHandler(requestMessage.method, cancellationSource.token);
          } else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
            handlerResult = requestHandler ? requestHandler(...requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
          } else {
            handlerResult = requestHandler ? requestHandler(requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
          }
          let promise = handlerResult;
          if (!handlerResult) {
            delete requestTokens[tokenKey];
            replySuccess(handlerResult, requestMessage.method, startTime);
          } else if (promise.then) {
            promise.then((resultOrError) => {
              delete requestTokens[tokenKey];
              reply(resultOrError, requestMessage.method, startTime);
            }, (error) => {
              delete requestTokens[tokenKey];
              if (error instanceof messages_1.ResponseError) {
                replyError(error, requestMessage.method, startTime);
              } else if (error && Is.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            });
          } else {
            delete requestTokens[tokenKey];
            reply(handlerResult, requestMessage.method, startTime);
          }
        } catch (error) {
          delete requestTokens[tokenKey];
          if (error instanceof messages_1.ResponseError) {
            reply(error, requestMessage.method, startTime);
          } else if (error && Is.string(error.message)) {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
          }
        }
      } else {
        replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
      }
    }
    function handleResponse(responseMessage) {
      if (isDisposed()) {
        return;
      }
      if (responseMessage.id === null) {
        if (responseMessage.error) {
          logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
        } else {
          logger.error(`Received response message without id. No further error information provided.`);
        }
      } else {
        let key = String(responseMessage.id);
        let responsePromise = responsePromises[key];
        traceReceivedResponse(responseMessage, responsePromise);
        if (responsePromise) {
          delete responsePromises[key];
          try {
            if (responseMessage.error) {
              let error = responseMessage.error;
              responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
            } else if (responseMessage.result !== void 0) {
              responsePromise.resolve(responseMessage.result);
            } else {
              throw new Error("Should never happen.");
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
            }
          }
        }
      }
    }
    function handleNotification(message) {
      if (isDisposed()) {
        return;
      }
      let type = void 0;
      let notificationHandler;
      if (message.method === CancelNotification.type.method) {
        notificationHandler = (params) => {
          let id = params.id;
          let source = requestTokens[String(id)];
          if (source) {
            source.cancel();
          }
        };
      } else {
        let element = notificationHandlers[message.method];
        if (element) {
          notificationHandler = element.handler;
          type = element.type;
        }
      }
      if (notificationHandler || starNotificationHandler) {
        try {
          traceReceivedNotification(message);
          if (message.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
            notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
          } else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
            notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
          } else {
            notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
          }
        } catch (error) {
          if (error.message) {
            logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
          } else {
            logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
          }
        }
      } else {
        unhandledNotificationEmitter.fire(message);
      }
    }
    function handleInvalidMessage(message) {
      if (!message) {
        logger.error("Received empty message.");
        return;
      }
      logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
      let responseMessage = message;
      if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
        let key = String(responseMessage.id);
        let responseHandler = responsePromises[key];
        if (responseHandler) {
          responseHandler.reject(new Error("The received response has neither a result nor an error property."));
        }
      }
    }
    function traceSendingRequest(message) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("send-request", message);
      }
    }
    function traceSendingNotification(message) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Sending notification '${message.method}'.`, data);
      } else {
        logLSPMessage("send-notification", message);
      }
    }
    function traceSendingResponse(message, method, startTime) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
      } else {
        logLSPMessage("send-response", message);
      }
    }
    function traceReceivedRequest(message) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose && message.params) {
          data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
        }
        tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("receive-request", message);
      }
    }
    function traceReceivedNotification(message) {
      if (trace === Trace2.Off || !tracer || message.method === LogTraceNotification.type.method) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose) {
          if (message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          } else {
            data = "No parameters provided.\n\n";
          }
        }
        tracer.log(`Received notification '${message.method}'.`, data);
      } else {
        logLSPMessage("receive-notification", message);
      }
    }
    function traceReceivedResponse(message, responsePromise) {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = void 0;
        if (trace === Trace2.Verbose) {
          if (message.error && message.error.data) {
            data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
          } else {
            if (message.result) {
              data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
            } else if (message.error === void 0) {
              data = "No result returned.\n\n";
            }
          }
        }
        if (responsePromise) {
          let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
          tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
        } else {
          tracer.log(`Received response ${message.id} without active response promise.`, data);
        }
      } else {
        logLSPMessage("receive-response", message);
      }
    }
    function logLSPMessage(type, message) {
      if (!tracer || trace === Trace2.Off) {
        return;
      }
      const lspMessage = {
        isLSPMessage: true,
        type,
        message,
        timestamp: Date.now()
      };
      tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
      if (isClosed()) {
        throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
      }
      if (isDisposed()) {
        throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
      }
    }
    function throwIfListening() {
      if (isListening()) {
        throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
      }
    }
    function throwIfNotListening() {
      if (!isListening()) {
        throw new Error("Call listen() first.");
      }
    }
    function undefinedToNull(param) {
      if (param === void 0) {
        return null;
      } else {
        return param;
      }
    }
    function computeMessageParams(type, params) {
      let result;
      let numberOfParams = type.numberOfParams;
      switch (numberOfParams) {
        case 0:
          result = null;
          break;
        case 1:
          result = undefinedToNull(params[0]);
          break;
        default:
          result = [];
          for (let i = 0; i < params.length && i < numberOfParams; i++) {
            result.push(undefinedToNull(params[i]));
          }
          if (params.length < numberOfParams) {
            for (let i = params.length; i < numberOfParams; i++) {
              result.push(null);
            }
          }
          break;
      }
      return result;
    }
    let connection = {
      sendNotification: (type, ...params) => {
        throwIfClosedOrDisposed();
        let method;
        let messageParams;
        if (Is.string(type)) {
          method = type;
          switch (params.length) {
            case 0:
              messageParams = null;
              break;
            case 1:
              messageParams = params[0];
              break;
            default:
              messageParams = params;
              break;
          }
        } else {
          method = type.method;
          messageParams = computeMessageParams(type, params);
        }
        let notificationMessage = {
          jsonrpc: version,
          method,
          params: messageParams
        };
        traceSendingNotification(notificationMessage);
        messageWriter.write(notificationMessage);
      },
      onNotification: (type, handler) => {
        throwIfClosedOrDisposed();
        if (Is.func(type)) {
          starNotificationHandler = type;
        } else if (handler) {
          if (Is.string(type)) {
            notificationHandlers[type] = {type: void 0, handler};
          } else {
            notificationHandlers[type.method] = {type, handler};
          }
        }
      },
      onProgress: (_type, token, handler) => {
        if (progressHandlers.has(token)) {
          throw new Error(`Progress handler for token ${token} already registered`);
        }
        progressHandlers.set(token, handler);
        return {
          dispose: () => {
            progressHandlers.delete(token);
          }
        };
      },
      sendProgress: (_type, token, value) => {
        connection.sendNotification(ProgressNotification.type, {token, value});
      },
      onUnhandledProgress: unhandledProgressEmitter.event,
      sendRequest: (type, ...params) => {
        throwIfClosedOrDisposed();
        throwIfNotListening();
        let method;
        let messageParams;
        let token = void 0;
        if (Is.string(type)) {
          method = type;
          switch (params.length) {
            case 0:
              messageParams = null;
              break;
            case 1:
              if (cancellation_1.CancellationToken.is(params[0])) {
                messageParams = null;
                token = params[0];
              } else {
                messageParams = undefinedToNull(params[0]);
              }
              break;
            default:
              const last = params.length - 1;
              if (cancellation_1.CancellationToken.is(params[last])) {
                token = params[last];
                if (params.length === 2) {
                  messageParams = undefinedToNull(params[0]);
                } else {
                  messageParams = params.slice(0, last).map((value) => undefinedToNull(value));
                }
              } else {
                messageParams = params.map((value) => undefinedToNull(value));
              }
              break;
          }
        } else {
          method = type.method;
          messageParams = computeMessageParams(type, params);
          let numberOfParams = type.numberOfParams;
          token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
        }
        let id = sequenceNumber++;
        let result = new Promise((resolve, reject) => {
          let requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          let responsePromise = {method, timerStart: Date.now(), resolve, reject};
          traceSendingRequest(requestMessage);
          try {
            messageWriter.write(requestMessage);
          } catch (e) {
            responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
            responsePromise = null;
          }
          if (responsePromise) {
            responsePromises[String(id)] = responsePromise;
          }
        });
        if (token) {
          token.onCancellationRequested(() => {
            connection.sendNotification(CancelNotification.type, {id});
          });
        }
        return result;
      },
      onRequest: (type, handler) => {
        throwIfClosedOrDisposed();
        if (Is.func(type)) {
          starRequestHandler = type;
        } else if (handler) {
          if (Is.string(type)) {
            requestHandlers[type] = {type: void 0, handler};
          } else {
            requestHandlers[type.method] = {type, handler};
          }
        }
      },
      trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
        let _sendNotification = false;
        let _traceFormat = TraceFormat.Text;
        if (sendNotificationOrTraceOptions !== void 0) {
          if (Is.boolean(sendNotificationOrTraceOptions)) {
            _sendNotification = sendNotificationOrTraceOptions;
          } else {
            _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
            _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
          }
        }
        trace = _value;
        traceFormat = _traceFormat;
        if (trace === Trace2.Off) {
          tracer = void 0;
        } else {
          tracer = _tracer;
        }
        if (_sendNotification && !isClosed() && !isDisposed()) {
          connection.sendNotification(SetTraceNotification.type, {value: Trace2.toString(_value)});
        }
      },
      onError: errorEmitter.event,
      onClose: closeEmitter.event,
      onUnhandledNotification: unhandledNotificationEmitter.event,
      onDispose: disposeEmitter.event,
      dispose: () => {
        if (isDisposed()) {
          return;
        }
        state = ConnectionState.Disposed;
        disposeEmitter.fire(void 0);
        let error = new Error("Connection got disposed.");
        Object.keys(responsePromises).forEach((key) => {
          responsePromises[key].reject(error);
        });
        responsePromises = Object.create(null);
        requestTokens = Object.create(null);
        messageQueue = new linkedMap_1.LinkedMap();
        if (Is.func(messageWriter.dispose)) {
          messageWriter.dispose();
        }
        if (Is.func(messageReader.dispose)) {
          messageReader.dispose();
        }
      },
      listen: () => {
        throwIfClosedOrDisposed();
        throwIfListening();
        state = ConnectionState.Listening;
        messageReader.listen(callback);
      },
      inspect: () => {
        console.log("inspect");
      }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
      if (trace === Trace2.Off || !tracer) {
        return;
      }
      tracer.log(params.message, trace === Trace2.Verbose ? params.verbose : void 0);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
      const handler = progressHandlers.get(params.token);
      if (handler) {
        handler(params.value);
      } else {
        unhandledProgressEmitter.fire(params);
      }
    });
    return connection;
  }
  function isMessageReader(value) {
    return value.listen !== void 0 && value.read === void 0;
  }
  function isMessageWriter(value) {
    return value.write !== void 0 && value.end === void 0;
  }
  function createMessageConnection(input, output, logger, strategy) {
    if (!logger) {
      logger = exports2.NullLogger;
    }
    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return _createMessageConnection(reader, writer, logger, strategy);
  }
  exports2.createMessageConnection = createMessageConnection;
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var require_main2 = __commonJS((exports2) => {
  __export(exports2, {
    CodeAction: () => CodeAction6,
    CodeActionContext: () => CodeActionContext6,
    CodeActionKind: () => CodeActionKind6,
    CodeLens: () => CodeLens2,
    Color: () => Color,
    ColorInformation: () => ColorInformation,
    ColorPresentation: () => ColorPresentation,
    Command: () => Command5,
    CompletionItem: () => CompletionItem4,
    CompletionItemKind: () => CompletionItemKind3,
    CompletionItemTag: () => CompletionItemTag,
    CompletionList: () => CompletionList3,
    CreateFile: () => CreateFile,
    DeleteFile: () => DeleteFile,
    Diagnostic: () => Diagnostic5,
    DiagnosticRelatedInformation: () => DiagnosticRelatedInformation2,
    DiagnosticSeverity: () => DiagnosticSeverity3,
    DiagnosticTag: () => DiagnosticTag,
    DocumentHighlight: () => DocumentHighlight2,
    DocumentHighlightKind: () => DocumentHighlightKind2,
    DocumentLink: () => DocumentLink,
    DocumentSymbol: () => DocumentSymbol2,
    EOL: () => EOL,
    FoldingRange: () => FoldingRange2,
    FoldingRangeKind: () => FoldingRangeKind,
    FormattingOptions: () => FormattingOptions,
    Hover: () => Hover,
    InsertTextFormat: () => InsertTextFormat3,
    Location: () => Location3,
    LocationLink: () => LocationLink,
    MarkedString: () => MarkedString,
    MarkupContent: () => MarkupContent3,
    MarkupKind: () => MarkupKind3,
    ParameterInformation: () => ParameterInformation,
    Position: () => Position8,
    Range: () => Range16,
    RenameFile: () => RenameFile,
    SelectionRange: () => SelectionRange,
    SignatureInformation: () => SignatureInformation,
    SymbolInformation: () => SymbolInformation2,
    SymbolKind: () => SymbolKind3,
    SymbolTag: () => SymbolTag,
    TextDocument: () => TextDocument11,
    TextDocumentEdit: () => TextDocumentEdit,
    TextDocumentIdentifier: () => TextDocumentIdentifier,
    TextDocumentItem: () => TextDocumentItem,
    TextEdit: () => TextEdit6,
    VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
    WorkspaceChange: () => WorkspaceChange,
    WorkspaceEdit: () => WorkspaceEdit6
  });
  "use strict";
  var Position8;
  (function(Position9) {
    function create(line, character) {
      return {line, character};
    }
    Position9.create = create;
    function is2(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
    }
    Position9.is = is2;
  })(Position8 || (Position8 = {}));
  var Range16;
  (function(Range17) {
    function create(one, two, three, four) {
      if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
        return {start: Position8.create(one, two), end: Position8.create(three, four)};
      } else if (Position8.is(one) && Position8.is(two)) {
        return {start: one, end: two};
      } else {
        throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
      }
    }
    Range17.create = create;
    function is2(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Position8.is(candidate.start) && Position8.is(candidate.end);
    }
    Range17.is = is2;
  })(Range16 || (Range16 = {}));
  var Location3;
  (function(Location4) {
    function create(uri, range) {
      return {uri, range};
    }
    Location4.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Range16.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location4.is = is2;
  })(Location3 || (Location3 = {}));
  var LocationLink;
  (function(LocationLink2) {
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
      return {targetUri, targetRange, targetSelectionRange, originSelectionRange};
    }
    LocationLink2.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Range16.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range16.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range16.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink2.is = is2;
  })(LocationLink || (LocationLink = {}));
  var Color;
  (function(Color2) {
    function create(red, green, blue, alpha) {
      return {
        red,
        green,
        blue,
        alpha
      };
    }
    Color2.create = create;
    function is2(value) {
      var candidate = value;
      return Is.number(candidate.red) && Is.number(candidate.green) && Is.number(candidate.blue) && Is.number(candidate.alpha);
    }
    Color2.is = is2;
  })(Color || (Color = {}));
  var ColorInformation;
  (function(ColorInformation2) {
    function create(range, color) {
      return {
        range,
        color
      };
    }
    ColorInformation2.create = create;
    function is2(value) {
      var candidate = value;
      return Range16.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation2.is = is2;
  })(ColorInformation || (ColorInformation = {}));
  var ColorPresentation;
  (function(ColorPresentation2) {
    function create(label, textEdit, additionalTextEdits) {
      return {
        label,
        textEdit,
        additionalTextEdits
      };
    }
    ColorPresentation2.create = create;
    function is2(value) {
      var candidate = value;
      return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit6.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit6.is));
    }
    ColorPresentation2.is = is2;
  })(ColorPresentation || (ColorPresentation = {}));
  var FoldingRangeKind;
  (function(FoldingRangeKind2) {
    FoldingRangeKind2["Comment"] = "comment";
    FoldingRangeKind2["Imports"] = "imports";
    FoldingRangeKind2["Region"] = "region";
  })(FoldingRangeKind || (FoldingRangeKind = {}));
  var FoldingRange2;
  (function(FoldingRange3) {
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
      var result = {
        startLine,
        endLine
      };
      if (Is.defined(startCharacter)) {
        result.startCharacter = startCharacter;
      }
      if (Is.defined(endCharacter)) {
        result.endCharacter = endCharacter;
      }
      if (Is.defined(kind)) {
        result.kind = kind;
      }
      return result;
    }
    FoldingRange3.create = create;
    function is2(value) {
      var candidate = value;
      return Is.number(candidate.startLine) && Is.number(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange3.is = is2;
  })(FoldingRange2 || (FoldingRange2 = {}));
  var DiagnosticRelatedInformation2;
  (function(DiagnosticRelatedInformation3) {
    function create(location, message) {
      return {
        location,
        message
      };
    }
    DiagnosticRelatedInformation3.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Location3.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation3.is = is2;
  })(DiagnosticRelatedInformation2 || (DiagnosticRelatedInformation2 = {}));
  var DiagnosticSeverity3;
  (function(DiagnosticSeverity4) {
    DiagnosticSeverity4.Error = 1;
    DiagnosticSeverity4.Warning = 2;
    DiagnosticSeverity4.Information = 3;
    DiagnosticSeverity4.Hint = 4;
  })(DiagnosticSeverity3 || (DiagnosticSeverity3 = {}));
  var DiagnosticTag;
  (function(DiagnosticTag2) {
    DiagnosticTag2.Unnecessary = 1;
    DiagnosticTag2.Deprecated = 2;
  })(DiagnosticTag || (DiagnosticTag = {}));
  var Diagnostic5;
  (function(Diagnostic6) {
    function create(range, message, severity, code, source, relatedInformation) {
      var result = {range, message};
      if (Is.defined(severity)) {
        result.severity = severity;
      }
      if (Is.defined(code)) {
        result.code = code;
      }
      if (Is.defined(source)) {
        result.source = source;
      }
      if (Is.defined(relatedInformation)) {
        result.relatedInformation = relatedInformation;
      }
      return result;
    }
    Diagnostic6.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Range16.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation2.is));
    }
    Diagnostic6.is = is2;
  })(Diagnostic5 || (Diagnostic5 = {}));
  var Command5;
  (function(Command6) {
    function create(title, command) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var result = {title, command};
      if (Is.defined(args) && args.length > 0) {
        result.arguments = args;
      }
      return result;
    }
    Command6.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command6.is = is2;
  })(Command5 || (Command5 = {}));
  var TextEdit6;
  (function(TextEdit7) {
    function replace(range, newText) {
      return {range, newText};
    }
    TextEdit7.replace = replace;
    function insert(position, newText) {
      return {range: {start: position, end: position}, newText};
    }
    TextEdit7.insert = insert;
    function del(range) {
      return {range, newText: ""};
    }
    TextEdit7.del = del;
    function is2(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range16.is(candidate.range);
    }
    TextEdit7.is = is2;
  })(TextEdit6 || (TextEdit6 = {}));
  var TextDocumentEdit;
  (function(TextDocumentEdit2) {
    function create(textDocument, edits) {
      return {textDocument, edits};
    }
    TextDocumentEdit2.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && VersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
    }
    TextDocumentEdit2.is = is2;
  })(TextDocumentEdit || (TextDocumentEdit = {}));
  var CreateFile;
  (function(CreateFile2) {
    function create(uri, options) {
      var result = {
        kind: "create",
        uri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      return result;
    }
    CreateFile2.create = create;
    function is2(value) {
      var candidate = value;
      return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists)));
    }
    CreateFile2.is = is2;
  })(CreateFile || (CreateFile = {}));
  var RenameFile;
  (function(RenameFile2) {
    function create(oldUri, newUri, options) {
      var result = {
        kind: "rename",
        oldUri,
        newUri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      return result;
    }
    RenameFile2.create = create;
    function is2(value) {
      var candidate = value;
      return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists)));
    }
    RenameFile2.is = is2;
  })(RenameFile || (RenameFile = {}));
  var DeleteFile;
  (function(DeleteFile2) {
    function create(uri, options) {
      var result = {
        kind: "delete",
        uri
      };
      if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
        result.options = options;
      }
      return result;
    }
    DeleteFile2.create = create;
    function is2(value) {
      var candidate = value;
      return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists)));
    }
    DeleteFile2.is = is2;
  })(DeleteFile || (DeleteFile = {}));
  var WorkspaceEdit6;
  (function(WorkspaceEdit7) {
    function is2(value) {
      var candidate = value;
      return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
        if (Is.string(change.kind)) {
          return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
        } else {
          return TextDocumentEdit.is(change);
        }
      }));
    }
    WorkspaceEdit7.is = is2;
  })(WorkspaceEdit6 || (WorkspaceEdit6 = {}));
  var TextEditChangeImpl = function() {
    function TextEditChangeImpl2(edits) {
      this.edits = edits;
    }
    TextEditChangeImpl2.prototype.insert = function(position, newText) {
      this.edits.push(TextEdit6.insert(position, newText));
    };
    TextEditChangeImpl2.prototype.replace = function(range, newText) {
      this.edits.push(TextEdit6.replace(range, newText));
    };
    TextEditChangeImpl2.prototype.delete = function(range) {
      this.edits.push(TextEdit6.del(range));
    };
    TextEditChangeImpl2.prototype.add = function(edit) {
      this.edits.push(edit);
    };
    TextEditChangeImpl2.prototype.all = function() {
      return this.edits;
    };
    TextEditChangeImpl2.prototype.clear = function() {
      this.edits.splice(0, this.edits.length);
    };
    return TextEditChangeImpl2;
  }();
  var WorkspaceChange = function() {
    function WorkspaceChange2(workspaceEdit) {
      var _this = this;
      this._textEditChanges = Object.create(null);
      if (workspaceEdit) {
        this._workspaceEdit = workspaceEdit;
        if (workspaceEdit.documentChanges) {
          workspaceEdit.documentChanges.forEach(function(change) {
            if (TextDocumentEdit.is(change)) {
              var textEditChange = new TextEditChangeImpl(change.edits);
              _this._textEditChanges[change.textDocument.uri] = textEditChange;
            }
          });
        } else if (workspaceEdit.changes) {
          Object.keys(workspaceEdit.changes).forEach(function(key) {
            var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
            _this._textEditChanges[key] = textEditChange;
          });
        }
      }
    }
    Object.defineProperty(WorkspaceChange2.prototype, "edit", {
      get: function() {
        return this._workspaceEdit;
      },
      enumerable: true,
      configurable: true
    });
    WorkspaceChange2.prototype.getTextEditChange = function(key) {
      if (VersionedTextDocumentIdentifier.is(key)) {
        if (!this._workspaceEdit) {
          this._workspaceEdit = {
            documentChanges: []
          };
        }
        if (!this._workspaceEdit.documentChanges) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var textDocument = key;
        var result = this._textEditChanges[textDocument.uri];
        if (!result) {
          var edits = [];
          var textDocumentEdit = {
            textDocument,
            edits
          };
          this._workspaceEdit.documentChanges.push(textDocumentEdit);
          result = new TextEditChangeImpl(edits);
          this._textEditChanges[textDocument.uri] = result;
        }
        return result;
      } else {
        if (!this._workspaceEdit) {
          this._workspaceEdit = {
            changes: Object.create(null)
          };
        }
        if (!this._workspaceEdit.changes) {
          throw new Error("Workspace edit is not configured for normal text edit changes.");
        }
        var result = this._textEditChanges[key];
        if (!result) {
          var edits = [];
          this._workspaceEdit.changes[key] = edits;
          result = new TextEditChangeImpl(edits);
          this._textEditChanges[key] = result;
        }
        return result;
      }
    };
    WorkspaceChange2.prototype.createFile = function(uri, options) {
      this.checkDocumentChanges();
      this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
    };
    WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, options) {
      this.checkDocumentChanges();
      this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
    };
    WorkspaceChange2.prototype.deleteFile = function(uri, options) {
      this.checkDocumentChanges();
      this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
    };
    WorkspaceChange2.prototype.checkDocumentChanges = function() {
      if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
    };
    return WorkspaceChange2;
  }();
  var TextDocumentIdentifier;
  (function(TextDocumentIdentifier2) {
    function create(uri) {
      return {uri};
    }
    TextDocumentIdentifier2.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier2.is = is2;
  })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
  var VersionedTextDocumentIdentifier;
  (function(VersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return {uri, version};
    }
    VersionedTextDocumentIdentifier2.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));
    }
    VersionedTextDocumentIdentifier2.is = is2;
  })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
  var TextDocumentItem;
  (function(TextDocumentItem2) {
    function create(uri, languageId, version, text) {
      return {uri, languageId, version, text};
    }
    TextDocumentItem2.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem2.is = is2;
  })(TextDocumentItem || (TextDocumentItem = {}));
  var MarkupKind3;
  (function(MarkupKind4) {
    MarkupKind4.PlainText = "plaintext";
    MarkupKind4.Markdown = "markdown";
  })(MarkupKind3 || (MarkupKind3 = {}));
  (function(MarkupKind4) {
    function is2(value) {
      var candidate = value;
      return candidate === MarkupKind4.PlainText || candidate === MarkupKind4.Markdown;
    }
    MarkupKind4.is = is2;
  })(MarkupKind3 || (MarkupKind3 = {}));
  var MarkupContent3;
  (function(MarkupContent4) {
    function is2(value) {
      var candidate = value;
      return Is.objectLiteral(value) && MarkupKind3.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent4.is = is2;
  })(MarkupContent3 || (MarkupContent3 = {}));
  var CompletionItemKind3;
  (function(CompletionItemKind4) {
    CompletionItemKind4.Text = 1;
    CompletionItemKind4.Method = 2;
    CompletionItemKind4.Function = 3;
    CompletionItemKind4.Constructor = 4;
    CompletionItemKind4.Field = 5;
    CompletionItemKind4.Variable = 6;
    CompletionItemKind4.Class = 7;
    CompletionItemKind4.Interface = 8;
    CompletionItemKind4.Module = 9;
    CompletionItemKind4.Property = 10;
    CompletionItemKind4.Unit = 11;
    CompletionItemKind4.Value = 12;
    CompletionItemKind4.Enum = 13;
    CompletionItemKind4.Keyword = 14;
    CompletionItemKind4.Snippet = 15;
    CompletionItemKind4.Color = 16;
    CompletionItemKind4.File = 17;
    CompletionItemKind4.Reference = 18;
    CompletionItemKind4.Folder = 19;
    CompletionItemKind4.EnumMember = 20;
    CompletionItemKind4.Constant = 21;
    CompletionItemKind4.Struct = 22;
    CompletionItemKind4.Event = 23;
    CompletionItemKind4.Operator = 24;
    CompletionItemKind4.TypeParameter = 25;
  })(CompletionItemKind3 || (CompletionItemKind3 = {}));
  var InsertTextFormat3;
  (function(InsertTextFormat4) {
    InsertTextFormat4.PlainText = 1;
    InsertTextFormat4.Snippet = 2;
  })(InsertTextFormat3 || (InsertTextFormat3 = {}));
  var CompletionItemTag;
  (function(CompletionItemTag2) {
    CompletionItemTag2.Deprecated = 1;
  })(CompletionItemTag || (CompletionItemTag = {}));
  var CompletionItem4;
  (function(CompletionItem5) {
    function create(label) {
      return {label};
    }
    CompletionItem5.create = create;
  })(CompletionItem4 || (CompletionItem4 = {}));
  var CompletionList3;
  (function(CompletionList4) {
    function create(items, isIncomplete) {
      return {items: items ? items : [], isIncomplete: !!isIncomplete};
    }
    CompletionList4.create = create;
  })(CompletionList3 || (CompletionList3 = {}));
  var MarkedString;
  (function(MarkedString2) {
    function fromPlainText(plainText) {
      return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    MarkedString2.fromPlainText = fromPlainText;
    function is2(value) {
      var candidate = value;
      return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
    }
    MarkedString2.is = is2;
  })(MarkedString || (MarkedString = {}));
  var Hover;
  (function(Hover2) {
    function is2(value) {
      var candidate = value;
      return !!candidate && Is.objectLiteral(candidate) && (MarkupContent3.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range16.is(value.range));
    }
    Hover2.is = is2;
  })(Hover || (Hover = {}));
  var ParameterInformation;
  (function(ParameterInformation2) {
    function create(label, documentation) {
      return documentation ? {label, documentation} : {label};
    }
    ParameterInformation2.create = create;
  })(ParameterInformation || (ParameterInformation = {}));
  var SignatureInformation;
  (function(SignatureInformation2) {
    function create(label, documentation) {
      var parameters = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        parameters[_i - 2] = arguments[_i];
      }
      var result = {label};
      if (Is.defined(documentation)) {
        result.documentation = documentation;
      }
      if (Is.defined(parameters)) {
        result.parameters = parameters;
      } else {
        result.parameters = [];
      }
      return result;
    }
    SignatureInformation2.create = create;
  })(SignatureInformation || (SignatureInformation = {}));
  var DocumentHighlightKind2;
  (function(DocumentHighlightKind3) {
    DocumentHighlightKind3.Text = 1;
    DocumentHighlightKind3.Read = 2;
    DocumentHighlightKind3.Write = 3;
  })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
  var DocumentHighlight2;
  (function(DocumentHighlight3) {
    function create(range, kind) {
      var result = {range};
      if (Is.number(kind)) {
        result.kind = kind;
      }
      return result;
    }
    DocumentHighlight3.create = create;
  })(DocumentHighlight2 || (DocumentHighlight2 = {}));
  var SymbolKind3;
  (function(SymbolKind4) {
    SymbolKind4.File = 1;
    SymbolKind4.Module = 2;
    SymbolKind4.Namespace = 3;
    SymbolKind4.Package = 4;
    SymbolKind4.Class = 5;
    SymbolKind4.Method = 6;
    SymbolKind4.Property = 7;
    SymbolKind4.Field = 8;
    SymbolKind4.Constructor = 9;
    SymbolKind4.Enum = 10;
    SymbolKind4.Interface = 11;
    SymbolKind4.Function = 12;
    SymbolKind4.Variable = 13;
    SymbolKind4.Constant = 14;
    SymbolKind4.String = 15;
    SymbolKind4.Number = 16;
    SymbolKind4.Boolean = 17;
    SymbolKind4.Array = 18;
    SymbolKind4.Object = 19;
    SymbolKind4.Key = 20;
    SymbolKind4.Null = 21;
    SymbolKind4.EnumMember = 22;
    SymbolKind4.Struct = 23;
    SymbolKind4.Event = 24;
    SymbolKind4.Operator = 25;
    SymbolKind4.TypeParameter = 26;
  })(SymbolKind3 || (SymbolKind3 = {}));
  var SymbolTag;
  (function(SymbolTag2) {
    SymbolTag2.Deprecated = 1;
  })(SymbolTag || (SymbolTag = {}));
  var SymbolInformation2;
  (function(SymbolInformation3) {
    function create(name, kind, range, uri, containerName) {
      var result = {
        name,
        kind,
        location: {uri, range}
      };
      if (containerName) {
        result.containerName = containerName;
      }
      return result;
    }
    SymbolInformation3.create = create;
  })(SymbolInformation2 || (SymbolInformation2 = {}));
  var DocumentSymbol2;
  (function(DocumentSymbol3) {
    function create(name, detail, kind, range, selectionRange, children) {
      var result = {
        name,
        detail,
        kind,
        range,
        selectionRange
      };
      if (children !== void 0) {
        result.children = children;
      }
      return result;
    }
    DocumentSymbol3.create = create;
    function is2(value) {
      var candidate = value;
      return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range16.is(candidate.range) && Range16.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children));
    }
    DocumentSymbol3.is = is2;
  })(DocumentSymbol2 || (DocumentSymbol2 = {}));
  var CodeActionKind6;
  (function(CodeActionKind7) {
    CodeActionKind7.Empty = "";
    CodeActionKind7.QuickFix = "quickfix";
    CodeActionKind7.Refactor = "refactor";
    CodeActionKind7.RefactorExtract = "refactor.extract";
    CodeActionKind7.RefactorInline = "refactor.inline";
    CodeActionKind7.RefactorRewrite = "refactor.rewrite";
    CodeActionKind7.Source = "source";
    CodeActionKind7.SourceOrganizeImports = "source.organizeImports";
    CodeActionKind7.SourceFixAll = "source.fixAll";
  })(CodeActionKind6 || (CodeActionKind6 = {}));
  var CodeActionContext6;
  (function(CodeActionContext7) {
    function create(diagnostics, only) {
      var result = {diagnostics};
      if (only !== void 0 && only !== null) {
        result.only = only;
      }
      return result;
    }
    CodeActionContext7.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic5.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext7.is = is2;
  })(CodeActionContext6 || (CodeActionContext6 = {}));
  var CodeAction6;
  (function(CodeAction7) {
    function create(title, commandOrEdit, kind) {
      var result = {title};
      if (Command5.is(commandOrEdit)) {
        result.command = commandOrEdit;
      } else {
        result.edit = commandOrEdit;
      }
      if (kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    CodeAction7.create = create;
    function is2(value) {
      var candidate = value;
      return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic5.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command5.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit6.is(candidate.edit));
    }
    CodeAction7.is = is2;
  })(CodeAction6 || (CodeAction6 = {}));
  var CodeLens2;
  (function(CodeLens3) {
    function create(range, data) {
      var result = {range};
      if (Is.defined(data)) {
        result.data = data;
      }
      return result;
    }
    CodeLens3.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Range16.is(candidate.range) && (Is.undefined(candidate.command) || Command5.is(candidate.command));
    }
    CodeLens3.is = is2;
  })(CodeLens2 || (CodeLens2 = {}));
  var FormattingOptions;
  (function(FormattingOptions2) {
    function create(tabSize, insertSpaces) {
      return {tabSize, insertSpaces};
    }
    FormattingOptions2.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions2.is = is2;
  })(FormattingOptions || (FormattingOptions = {}));
  var DocumentLink;
  (function(DocumentLink2) {
    function create(range, target, data) {
      return {range, target, data};
    }
    DocumentLink2.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Range16.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink2.is = is2;
  })(DocumentLink || (DocumentLink = {}));
  var SelectionRange;
  (function(SelectionRange2) {
    function create(range, parent) {
      return {range, parent};
    }
    SelectionRange2.create = create;
    function is2(value) {
      var candidate = value;
      return candidate !== void 0 && Range16.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
    }
    SelectionRange2.is = is2;
  })(SelectionRange || (SelectionRange = {}));
  var EOL = ["\n", "\r\n", "\r"];
  var TextDocument11;
  (function(TextDocument12) {
    function create(uri, languageId, version, content) {
      return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument12.create = create;
    function is2(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument12.is = is2;
    function applyEdits(document, edits) {
      var text = document.getText();
      var sortedEdits = mergeSort(edits, function(a, b) {
        var diff = a.range.start.line - b.range.start.line;
        if (diff === 0) {
          return a.range.start.character - b.range.start.character;
        }
        return diff;
      });
      var lastModifiedOffset = text.length;
      for (var i = sortedEdits.length - 1; i >= 0; i--) {
        var e = sortedEdits[i];
        var startOffset = document.offsetAt(e.range.start);
        var endOffset = document.offsetAt(e.range.end);
        if (endOffset <= lastModifiedOffset) {
          text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
        } else {
          throw new Error("Overlapping edit");
        }
        lastModifiedOffset = startOffset;
      }
      return text;
    }
    TextDocument12.applyEdits = applyEdits;
    function mergeSort(data, compare) {
      if (data.length <= 1) {
        return data;
      }
      var p = data.length / 2 | 0;
      var left = data.slice(0, p);
      var right = data.slice(p);
      mergeSort(left, compare);
      mergeSort(right, compare);
      var leftIdx = 0;
      var rightIdx = 0;
      var i = 0;
      while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
          data[i++] = left[leftIdx++];
        } else {
          data[i++] = right[rightIdx++];
        }
      }
      while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
      }
      while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
      }
      return data;
    }
  })(TextDocument11 || (TextDocument11 = {}));
  var FullTextDocument = function() {
    function FullTextDocument2(uri, languageId, version, content) {
      this._uri = uri;
      this._languageId = languageId;
      this._version = version;
      this._content = content;
      this._lineOffsets = void 0;
    }
    Object.defineProperty(FullTextDocument2.prototype, "uri", {
      get: function() {
        return this._uri;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FullTextDocument2.prototype, "languageId", {
      get: function() {
        return this._languageId;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(FullTextDocument2.prototype, "version", {
      get: function() {
        return this._version;
      },
      enumerable: true,
      configurable: true
    });
    FullTextDocument2.prototype.getText = function(range) {
      if (range) {
        var start = this.offsetAt(range.start);
        var end = this.offsetAt(range.end);
        return this._content.substring(start, end);
      }
      return this._content;
    };
    FullTextDocument2.prototype.update = function(event, version) {
      this._content = event.text;
      this._version = version;
      this._lineOffsets = void 0;
    };
    FullTextDocument2.prototype.getLineOffsets = function() {
      if (this._lineOffsets === void 0) {
        var lineOffsets = [];
        var text = this._content;
        var isLineStart = true;
        for (var i = 0; i < text.length; i++) {
          if (isLineStart) {
            lineOffsets.push(i);
            isLineStart = false;
          }
          var ch = text.charAt(i);
          isLineStart = ch === "\r" || ch === "\n";
          if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
            i++;
          }
        }
        if (isLineStart && text.length > 0) {
          lineOffsets.push(text.length);
        }
        this._lineOffsets = lineOffsets;
      }
      return this._lineOffsets;
    };
    FullTextDocument2.prototype.positionAt = function(offset) {
      offset = Math.max(Math.min(offset, this._content.length), 0);
      var lineOffsets = this.getLineOffsets();
      var low = 0, high = lineOffsets.length;
      if (high === 0) {
        return Position8.create(0, offset);
      }
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (lineOffsets[mid] > offset) {
          high = mid;
        } else {
          low = mid + 1;
        }
      }
      var line = low - 1;
      return Position8.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument2.prototype.offsetAt = function(position) {
      var lineOffsets = this.getLineOffsets();
      if (position.line >= lineOffsets.length) {
        return this._content.length;
      } else if (position.line < 0) {
        return 0;
      }
      var lineOffset = lineOffsets[position.line];
      var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
      return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
      get: function() {
        return this.getLineOffsets().length;
      },
      enumerable: true,
      configurable: true
    });
    return FullTextDocument2;
  }();
  var Is;
  (function(Is2) {
    var toString2 = Object.prototype.toString;
    function defined(value) {
      return typeof value !== "undefined";
    }
    Is2.defined = defined;
    function undefined2(value) {
      return typeof value === "undefined";
    }
    Is2.undefined = undefined2;
    function boolean2(value) {
      return value === true || value === false;
    }
    Is2.boolean = boolean2;
    function string2(value) {
      return toString2.call(value) === "[object String]";
    }
    Is2.string = string2;
    function number(value) {
      return toString2.call(value) === "[object Number]";
    }
    Is2.number = number;
    function func(value) {
      return toString2.call(value) === "[object Function]";
    }
    Is2.func = func;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    Is2.objectLiteral = objectLiteral;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    Is2.typedArray = typedArray;
  })(Is || (Is = {}));
});

// node_modules/vscode-languageserver-protocol/lib/utils/is.js
var require_is2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function boolean2(value) {
    return value === true || value === false;
  }
  exports2.boolean = boolean2;
  function string2(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports2.string = string2;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports2.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports2.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports2.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports2.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string2(elem));
  }
  exports2.stringArray = stringArray;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  exports2.typedArray = typedArray;
  function objectLiteral(value) {
    return value !== null && typeof value === "object";
  }
  exports2.objectLiteral = objectLiteral;
});

// node_modules/vscode-languageserver-protocol/lib/messages.js
var require_messages2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolRequestType0 = ProtocolRequestType0;
  var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolRequestType = ProtocolRequestType;
  var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolNotificationType = ProtocolNotificationType;
  var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
      super(method);
    }
  };
  exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
});

// node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js
var require_protocol_implementation = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var ImplementationRequest;
  (function(ImplementationRequest2) {
    ImplementationRequest2.method = "textDocument/implementation";
    ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    ImplementationRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var TypeDefinitionRequest;
  (function(TypeDefinitionRequest2) {
    TypeDefinitionRequest2.method = "textDocument/typeDefinition";
    TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    TypeDefinitionRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var WorkspaceFoldersRequest;
  (function(WorkspaceFoldersRequest2) {
    WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
  })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
  var DidChangeWorkspaceFoldersNotification;
  (function(DidChangeWorkspaceFoldersNotification2) {
    DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
  })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js
var require_protocol_configuration = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var ConfigurationRequest;
  (function(ConfigurationRequest2) {
    ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
  })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var DocumentColorRequest;
  (function(DocumentColorRequest2) {
    DocumentColorRequest2.method = "textDocument/documentColor";
    DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    DocumentColorRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
  var ColorPresentationRequest;
  (function(ColorPresentationRequest2) {
    ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
  })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var FoldingRangeKind;
  (function(FoldingRangeKind2) {
    FoldingRangeKind2["Comment"] = "comment";
    FoldingRangeKind2["Imports"] = "imports";
    FoldingRangeKind2["Region"] = "region";
  })(FoldingRangeKind = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
  var FoldingRangeRequest;
  (function(FoldingRangeRequest2) {
    FoldingRangeRequest2.method = "textDocument/foldingRange";
    FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    FoldingRangeRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js
var require_protocol_declaration = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var DeclarationRequest;
  (function(DeclarationRequest2) {
    DeclarationRequest2.method = "textDocument/declaration";
    DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    DeclarationRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var SelectionRangeRequest;
  (function(SelectionRangeRequest2) {
    SelectionRangeRequest2.method = "textDocument/selectionRange";
    SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    SelectionRangeRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.progress.js
var require_protocol_progress = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var WorkDoneProgress;
  (function(WorkDoneProgress2) {
    WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
  })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
  var WorkDoneProgressCreateRequest;
  (function(WorkDoneProgressCreateRequest2) {
    WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
  })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
  var WorkDoneProgressCancelNotification;
  (function(WorkDoneProgressCancelNotification2) {
    WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
  })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.js
var require_protocol = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Is = require_is2();
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var protocol_implementation_1 = require_protocol_implementation();
  exports2.ImplementationRequest = protocol_implementation_1.ImplementationRequest;
  var protocol_typeDefinition_1 = require_protocol_typeDefinition();
  exports2.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;
  var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
  exports2.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
  exports2.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
  var protocol_configuration_1 = require_protocol_configuration();
  exports2.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;
  var protocol_colorProvider_1 = require_protocol_colorProvider();
  exports2.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
  exports2.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;
  var protocol_foldingRange_1 = require_protocol_foldingRange();
  exports2.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;
  var protocol_declaration_1 = require_protocol_declaration();
  exports2.DeclarationRequest = protocol_declaration_1.DeclarationRequest;
  var protocol_selectionRange_1 = require_protocol_selectionRange();
  exports2.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;
  var protocol_progress_1 = require_protocol_progress();
  exports2.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;
  exports2.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;
  exports2.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification;
  var DocumentFilter;
  (function(DocumentFilter2) {
    function is2(value) {
      const candidate = value;
      return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter2.is = is2;
  })(DocumentFilter = exports2.DocumentFilter || (exports2.DocumentFilter = {}));
  var DocumentSelector2;
  (function(DocumentSelector3) {
    function is2(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (let elem of value) {
        if (!Is.string(elem) && !DocumentFilter.is(elem)) {
          return false;
        }
      }
      return true;
    }
    DocumentSelector3.is = is2;
  })(DocumentSelector2 = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
  var RegistrationRequest;
  (function(RegistrationRequest2) {
    RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
  })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
  var UnregistrationRequest;
  (function(UnregistrationRequest2) {
    UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
  })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
  var ResourceOperationKind;
  (function(ResourceOperationKind2) {
    ResourceOperationKind2.Create = "create";
    ResourceOperationKind2.Rename = "rename";
    ResourceOperationKind2.Delete = "delete";
  })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
  var FailureHandlingKind;
  (function(FailureHandlingKind2) {
    FailureHandlingKind2.Abort = "abort";
    FailureHandlingKind2.Transactional = "transactional";
    FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
    FailureHandlingKind2.Undo = "undo";
  })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
  var StaticRegistrationOptions;
  (function(StaticRegistrationOptions2) {
    function hasId(value) {
      const candidate = value;
      return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions2.hasId = hasId;
  })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
  var TextDocumentRegistrationOptions;
  (function(TextDocumentRegistrationOptions2) {
    function is2(value) {
      const candidate = value;
      return candidate && (candidate.documentSelector === null || DocumentSelector2.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions2.is = is2;
  })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
  var WorkDoneProgressOptions;
  (function(WorkDoneProgressOptions2) {
    function is2(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions2.is = is2;
    function hasWorkDoneProgress(value) {
      const candidate = value;
      return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
  })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
  var InitializeRequest;
  (function(InitializeRequest2) {
    InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
  })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
  var InitializeError;
  (function(InitializeError2) {
    InitializeError2.unknownProtocolVersion = 1;
  })(InitializeError = exports2.InitializeError || (exports2.InitializeError = {}));
  var InitializedNotification;
  (function(InitializedNotification2) {
    InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
  })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
  var ShutdownRequest;
  (function(ShutdownRequest2) {
    ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
  })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
  var ExitNotification;
  (function(ExitNotification2) {
    ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
  })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
  var DidChangeConfigurationNotification;
  (function(DidChangeConfigurationNotification2) {
    DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
  })(DidChangeConfigurationNotification = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2.Error = 1;
    MessageType2.Warning = 2;
    MessageType2.Info = 3;
    MessageType2.Log = 4;
  })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
  var ShowMessageNotification;
  (function(ShowMessageNotification2) {
    ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
  })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
  var ShowMessageRequest;
  (function(ShowMessageRequest2) {
    ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
  })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
  var LogMessageNotification;
  (function(LogMessageNotification2) {
    LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
  })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
  var TelemetryEventNotification;
  (function(TelemetryEventNotification2) {
    TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
  })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
  var TextDocumentSyncKind;
  (function(TextDocumentSyncKind2) {
    TextDocumentSyncKind2.None = 0;
    TextDocumentSyncKind2.Full = 1;
    TextDocumentSyncKind2.Incremental = 2;
  })(TextDocumentSyncKind = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
  var DidOpenTextDocumentNotification;
  (function(DidOpenTextDocumentNotification2) {
    DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
    DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
  })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
  var DidChangeTextDocumentNotification;
  (function(DidChangeTextDocumentNotification2) {
    DidChangeTextDocumentNotification2.method = "textDocument/didChange";
    DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
  })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
  var DidCloseTextDocumentNotification;
  (function(DidCloseTextDocumentNotification2) {
    DidCloseTextDocumentNotification2.method = "textDocument/didClose";
    DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
  })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
  var DidSaveTextDocumentNotification;
  (function(DidSaveTextDocumentNotification2) {
    DidSaveTextDocumentNotification2.method = "textDocument/didSave";
    DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
  })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
  var TextDocumentSaveReason;
  (function(TextDocumentSaveReason2) {
    TextDocumentSaveReason2.Manual = 1;
    TextDocumentSaveReason2.AfterDelay = 2;
    TextDocumentSaveReason2.FocusOut = 3;
  })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
  var WillSaveTextDocumentNotification;
  (function(WillSaveTextDocumentNotification2) {
    WillSaveTextDocumentNotification2.method = "textDocument/willSave";
    WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
  })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
  var WillSaveTextDocumentWaitUntilRequest;
  (function(WillSaveTextDocumentWaitUntilRequest2) {
    WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
    WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
  })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
  var DidChangeWatchedFilesNotification;
  (function(DidChangeWatchedFilesNotification2) {
    DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
  })(DidChangeWatchedFilesNotification = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
  var FileChangeType;
  (function(FileChangeType2) {
    FileChangeType2.Created = 1;
    FileChangeType2.Changed = 2;
    FileChangeType2.Deleted = 3;
  })(FileChangeType = exports2.FileChangeType || (exports2.FileChangeType = {}));
  var WatchKind;
  (function(WatchKind2) {
    WatchKind2.Create = 1;
    WatchKind2.Change = 2;
    WatchKind2.Delete = 4;
  })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
  var PublishDiagnosticsNotification;
  (function(PublishDiagnosticsNotification2) {
    PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
  })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
  var CompletionTriggerKind;
  (function(CompletionTriggerKind2) {
    CompletionTriggerKind2.Invoked = 1;
    CompletionTriggerKind2.TriggerCharacter = 2;
    CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
  })(CompletionTriggerKind = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
  var CompletionRequest;
  (function(CompletionRequest2) {
    CompletionRequest2.method = "textDocument/completion";
    CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    CompletionRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
  var CompletionResolveRequest;
  (function(CompletionResolveRequest2) {
    CompletionResolveRequest2.method = "completionItem/resolve";
    CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
  })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
  var HoverRequest;
  (function(HoverRequest2) {
    HoverRequest2.method = "textDocument/hover";
    HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
  })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
  var SignatureHelpTriggerKind;
  (function(SignatureHelpTriggerKind2) {
    SignatureHelpTriggerKind2.Invoked = 1;
    SignatureHelpTriggerKind2.TriggerCharacter = 2;
    SignatureHelpTriggerKind2.ContentChange = 3;
  })(SignatureHelpTriggerKind = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
  var SignatureHelpRequest;
  (function(SignatureHelpRequest2) {
    SignatureHelpRequest2.method = "textDocument/signatureHelp";
    SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
  })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
  var DefinitionRequest;
  (function(DefinitionRequest2) {
    DefinitionRequest2.method = "textDocument/definition";
    DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    DefinitionRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
  var ReferencesRequest;
  (function(ReferencesRequest2) {
    ReferencesRequest2.method = "textDocument/references";
    ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    ReferencesRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
  var DocumentHighlightRequest;
  (function(DocumentHighlightRequest2) {
    DocumentHighlightRequest2.method = "textDocument/documentHighlight";
    DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    DocumentHighlightRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
  var DocumentSymbolRequest;
  (function(DocumentSymbolRequest2) {
    DocumentSymbolRequest2.method = "textDocument/documentSymbol";
    DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    DocumentSymbolRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
  var CodeActionRequest;
  (function(CodeActionRequest2) {
    CodeActionRequest2.method = "textDocument/codeAction";
    CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    CodeActionRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(CodeActionRequest = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
  var WorkspaceSymbolRequest;
  (function(WorkspaceSymbolRequest2) {
    WorkspaceSymbolRequest2.method = "workspace/symbol";
    WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    WorkspaceSymbolRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
  var CodeLensRequest;
  (function(CodeLensRequest2) {
    CodeLensRequest2.type = new messages_1.ProtocolRequestType("textDocument/codeLens");
    CodeLensRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
  var CodeLensResolveRequest;
  (function(CodeLensResolveRequest2) {
    CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType("codeLens/resolve");
  })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
  var DocumentLinkRequest;
  (function(DocumentLinkRequest2) {
    DocumentLinkRequest2.method = "textDocument/documentLink";
    DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    DocumentLinkRequest2.resultType = new vscode_jsonrpc_1.ProgressType();
  })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
  var DocumentLinkResolveRequest;
  (function(DocumentLinkResolveRequest2) {
    DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType("documentLink/resolve");
  })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
  var DocumentFormattingRequest;
  (function(DocumentFormattingRequest2) {
    DocumentFormattingRequest2.method = "textDocument/formatting";
    DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
  })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
  var DocumentRangeFormattingRequest;
  (function(DocumentRangeFormattingRequest2) {
    DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
    DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
  })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
  var DocumentOnTypeFormattingRequest;
  (function(DocumentOnTypeFormattingRequest2) {
    DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
    DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
  })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
  var RenameRequest;
  (function(RenameRequest2) {
    RenameRequest2.method = "textDocument/rename";
    RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
  })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
  var PrepareRenameRequest;
  (function(PrepareRenameRequest2) {
    PrepareRenameRequest2.method = "textDocument/prepareRename";
    PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
  })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
  var ExecuteCommandRequest;
  (function(ExecuteCommandRequest2) {
    ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
  })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
  var ApplyWorkspaceEditRequest;
  (function(ApplyWorkspaceEditRequest2) {
    ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
  })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js
var require_protocol_callHierarchy_proposed = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var CallHierarchyPrepareRequest;
  (function(CallHierarchyPrepareRequest2) {
    CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
    CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
  })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
  var CallHierarchyIncomingCallsRequest;
  (function(CallHierarchyIncomingCallsRequest2) {
    CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
    CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
  })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
  var CallHierarchyOutgoingCallsRequest;
  (function(CallHierarchyOutgoingCallsRequest2) {
    CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
    CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
  })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js
var require_protocol_sematicTokens_proposed = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var messages_1 = require_messages2();
  var SemanticTokenTypes;
  (function(SemanticTokenTypes2) {
    SemanticTokenTypes2["comment"] = "comment";
    SemanticTokenTypes2["keyword"] = "keyword";
    SemanticTokenTypes2["string"] = "string";
    SemanticTokenTypes2["number"] = "number";
    SemanticTokenTypes2["regexp"] = "regexp";
    SemanticTokenTypes2["operator"] = "operator";
    SemanticTokenTypes2["namespace"] = "namespace";
    SemanticTokenTypes2["type"] = "type";
    SemanticTokenTypes2["struct"] = "struct";
    SemanticTokenTypes2["class"] = "class";
    SemanticTokenTypes2["interface"] = "interface";
    SemanticTokenTypes2["enum"] = "enum";
    SemanticTokenTypes2["typeParameter"] = "typeParameter";
    SemanticTokenTypes2["function"] = "function";
    SemanticTokenTypes2["member"] = "member";
    SemanticTokenTypes2["property"] = "property";
    SemanticTokenTypes2["macro"] = "macro";
    SemanticTokenTypes2["variable"] = "variable";
    SemanticTokenTypes2["parameter"] = "parameter";
    SemanticTokenTypes2["label"] = "label";
  })(SemanticTokenTypes = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
  var SemanticTokenModifiers;
  (function(SemanticTokenModifiers2) {
    SemanticTokenModifiers2["documentation"] = "documentation";
    SemanticTokenModifiers2["declaration"] = "declaration";
    SemanticTokenModifiers2["definition"] = "definition";
    SemanticTokenModifiers2["reference"] = "reference";
    SemanticTokenModifiers2["static"] = "static";
    SemanticTokenModifiers2["abstract"] = "abstract";
    SemanticTokenModifiers2["deprecated"] = "deprecated";
    SemanticTokenModifiers2["async"] = "async";
    SemanticTokenModifiers2["volatile"] = "volatile";
    SemanticTokenModifiers2["readonly"] = "readonly";
  })(SemanticTokenModifiers = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
  var SemanticTokens;
  (function(SemanticTokens2) {
    function is2(value) {
      const candidate = value;
      return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
    }
    SemanticTokens2.is = is2;
  })(SemanticTokens = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
  var SemanticTokensRequest;
  (function(SemanticTokensRequest2) {
    SemanticTokensRequest2.method = "textDocument/semanticTokens";
    SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
  })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
  var SemanticTokensEditsRequest;
  (function(SemanticTokensEditsRequest2) {
    SemanticTokensEditsRequest2.method = "textDocument/semanticTokens/edits";
    SemanticTokensEditsRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest2.method);
  })(SemanticTokensEditsRequest = exports2.SemanticTokensEditsRequest || (exports2.SemanticTokensEditsRequest = {}));
  var SemanticTokensRangeRequest;
  (function(SemanticTokensRangeRequest2) {
    SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
    SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
  })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/main.js
var require_main3 = __commonJS((exports2) => {
  "use strict";
  function __export2(m) {
    for (var p in m)
      if (!exports2.hasOwnProperty(p))
        exports2[p] = m[p];
  }
  Object.defineProperty(exports2, "__esModule", {value: true});
  var vscode_jsonrpc_1 = require_main();
  exports2.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
  exports2.ResponseError = vscode_jsonrpc_1.ResponseError;
  exports2.CancellationToken = vscode_jsonrpc_1.CancellationToken;
  exports2.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
  exports2.Disposable = vscode_jsonrpc_1.Disposable;
  exports2.Event = vscode_jsonrpc_1.Event;
  exports2.Emitter = vscode_jsonrpc_1.Emitter;
  exports2.Trace = vscode_jsonrpc_1.Trace;
  exports2.TraceFormat = vscode_jsonrpc_1.TraceFormat;
  exports2.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
  exports2.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
  exports2.RequestType = vscode_jsonrpc_1.RequestType;
  exports2.RequestType0 = vscode_jsonrpc_1.RequestType0;
  exports2.NotificationType = vscode_jsonrpc_1.NotificationType;
  exports2.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
  exports2.MessageReader = vscode_jsonrpc_1.MessageReader;
  exports2.MessageWriter = vscode_jsonrpc_1.MessageWriter;
  exports2.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
  exports2.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
  exports2.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
  exports2.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
  exports2.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
  exports2.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
  exports2.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
  exports2.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
  exports2.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
  exports2.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
  exports2.ProgressType = vscode_jsonrpc_1.ProgressType;
  __export2(require_main2());
  __export2(require_protocol());
  var callHierarchy = require_protocol_callHierarchy_proposed();
  var st = require_protocol_sematicTokens_proposed();
  var Proposed;
  (function(Proposed2) {
    let CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = callHierarchy.CallHierarchyPrepareRequest.method;
      CallHierarchyPrepareRequest2.type = callHierarchy.CallHierarchyPrepareRequest.type;
    })(CallHierarchyPrepareRequest = Proposed2.CallHierarchyPrepareRequest || (Proposed2.CallHierarchyPrepareRequest = {}));
    let CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = callHierarchy.CallHierarchyIncomingCallsRequest.method;
      CallHierarchyIncomingCallsRequest2.type = callHierarchy.CallHierarchyIncomingCallsRequest.type;
    })(CallHierarchyIncomingCallsRequest = Proposed2.CallHierarchyIncomingCallsRequest || (Proposed2.CallHierarchyIncomingCallsRequest = {}));
    let CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = callHierarchy.CallHierarchyOutgoingCallsRequest.method;
      CallHierarchyOutgoingCallsRequest2.type = callHierarchy.CallHierarchyOutgoingCallsRequest.type;
    })(CallHierarchyOutgoingCallsRequest = Proposed2.CallHierarchyOutgoingCallsRequest || (Proposed2.CallHierarchyOutgoingCallsRequest = {}));
    Proposed2.SemanticTokenTypes = st.SemanticTokenTypes;
    Proposed2.SemanticTokenModifiers = st.SemanticTokenModifiers;
    Proposed2.SemanticTokens = st.SemanticTokens;
    let SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = st.SemanticTokensRequest.method;
      SemanticTokensRequest2.type = st.SemanticTokensRequest.type;
    })(SemanticTokensRequest = Proposed2.SemanticTokensRequest || (Proposed2.SemanticTokensRequest = {}));
    let SemanticTokensEditsRequest;
    (function(SemanticTokensEditsRequest2) {
      SemanticTokensEditsRequest2.method = st.SemanticTokensEditsRequest.method;
      SemanticTokensEditsRequest2.type = st.SemanticTokensEditsRequest.type;
    })(SemanticTokensEditsRequest = Proposed2.SemanticTokensEditsRequest || (Proposed2.SemanticTokensEditsRequest = {}));
    let SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = st.SemanticTokensRangeRequest.method;
      SemanticTokensRangeRequest2.type = st.SemanticTokensRangeRequest.type;
    })(SemanticTokensRangeRequest = Proposed2.SemanticTokensRangeRequest || (Proposed2.SemanticTokensRangeRequest = {}));
  })(Proposed = exports2.Proposed || (exports2.Proposed = {}));
  function createProtocolConnection(reader, writer, logger, strategy) {
    return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger, strategy);
  }
  exports2.createProtocolConnection = createProtocolConnection;
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports2, module2) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  module2.exports = {
    SEMVER_SPEC_VERSION,
    MAX_LENGTH,
    MAX_SAFE_INTEGER,
    MAX_SAFE_COMPONENT_LENGTH
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports2, module2) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module2.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports2, module2) => {
  var {MAX_SAFE_COMPONENT_LENGTH} = require_constants();
  var debug = require_debug();
  exports2 = module2.exports = {};
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.t = {};
  var R = 0;
  var createToken = (name, value, isGlobal) => {
    const index = R++;
    debug(index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports2, module2) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module2.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports2, module2) => {
  var debug = require_debug();
  var {MAX_LENGTH, MAX_SAFE_INTEGER} = require_constants();
  var {re, t} = require_re();
  var {compareIdentifiers} = require_identifiers();
  var SemVer = class {
    constructor(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("prerelease compare", i, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.format();
      this.raw = this.version;
      return this;
    }
  };
  module2.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports2, module2) => {
  var {MAX_LENGTH} = require_constants();
  var {re, t} = require_re();
  var SemVer = require_semver();
  var parse = (version, options) => {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    const r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  };
  module2.exports = parse;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var valid2 = (version, options) => {
    const v = parse(version, options);
    return v ? v.version : null;
  };
  module2.exports = valid2;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var clean = (version, options) => {
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module2.exports = clean;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier) => {
    if (typeof options === "string") {
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer(version, options).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };
  module2.exports = inc;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module2.exports = compare;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module2.exports = eq;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var eq = require_eq();
  var diff = (version1, version2) => {
    if (eq(version1, version2)) {
      return null;
    } else {
      const v1 = parse(version1);
      const v2 = parse(version2);
      const hasPre = v1.prerelease.length || v2.prerelease.length;
      const prefix = hasPre ? "pre" : "";
      const defaultResult = hasPre ? "prerelease" : "";
      for (const key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  };
  module2.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module2.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module2.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module2.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var prerelease = (version, options) => {
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module2.exports = prerelease;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module2.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module2.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module2.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module2.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports2, module2) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module2.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module2.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module2.exports = lt;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module2.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gte2 = (a, b, loose) => compare(a, b, loose) >= 0;
  module2.exports = gte2;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module2.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports2, module2) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte2 = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte2(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module2.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var parse = require_parse();
  var {re, t} = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      let next;
      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null)
      return null;
    return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
  };
  module2.exports = coerce;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports2, module2) => {
  var Range16 = class {
    constructor(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range16) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range16(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${range}`);
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const loose = this.options.loose;
      range = range.trim();
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      return range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
    }
    intersects(range, options) {
      if (!(range instanceof Range16)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  };
  module2.exports = Range16;
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceTilde(comp2, options);
  }).join(" ");
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
    return replaceCaret(comp2, options);
  }).join(" ");
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((comp2) => {
      return replaceXRange(comp2, options);
    }).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<")
          pr = "-0";
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version, options) => {
    for (let i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports2, module2) => {
  var ANY = Symbol("SemVer ANY");
  var Comparator = class {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range16(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range16(this.value, options).test(comp.semver);
      }
      const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      const sameSemVer = this.semver.version === comp.semver.version;
      const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
      const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
  };
  module2.exports = Comparator;
  var {re, t} = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range16 = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports2, module2) => {
  var Range16 = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range16(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module2.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports2, module2) => {
  var Range16 = require_range();
  var toComparators = (range, options) => new Range16(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module2.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range16 = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range16(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module2.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range16 = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range16(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module2.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Range16 = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range16(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0; i < range.set.length; ++i) {
      const comparators = range.set[i];
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module2.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports2, module2) => {
  var Range16 = require_range();
  var validRange = (range, options) => {
    try {
      return new Range16(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module2.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var {ANY} = Comparator;
  var Range16 = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte2 = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range16(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte2;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0; i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module2.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module2.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports2, module2) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module2.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports2, module2) => {
  var Range16 = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range16(r1, options);
    r2 = new Range16(r2, options);
    return r1.intersects(r2);
  };
  module2.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports2, module2) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module2.exports = (versions, range, options) => {
    const set = [];
    let min = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version of v) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!min)
          min = version;
      } else {
        if (prev) {
          set.push([min, prev]);
        }
        prev = null;
        min = null;
      }
    }
    if (min)
      set.push([min, null]);
    const ranges = [];
    for (const [min2, max] of set) {
      if (min2 === max)
        ranges.push(min2);
      else if (!max && min2 === v[0])
        ranges.push("*");
      else if (!max)
        ranges.push(`>=${min2}`);
      else if (min2 === v[0])
        ranges.push(`<=${max}`);
      else
        ranges.push(`${min2} - ${max}`);
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports2, module2) => {
  var Range16 = require_range();
  var {ANY} = require_comparator();
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options) => {
    sub = new Range16(sub, options);
    dom = new Range16(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub)
            continue OUTER;
        }
        if (sawNonNull)
          return false;
      }
    return true;
  };
  var simpleSubset = (sub, dom, options) => {
    if (sub.length === 1 && sub[0].semver === ANY)
      return dom.length === 1 && dom[0].semver === ANY;
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=")
        gt = higherGT(gt, c, options);
      else if (c.operator === "<" || c.operator === "<=")
        lt = lowerLT(lt, c, options);
      else
        eqSet.add(c.semver);
    }
    if (eqSet.size > 1)
      return null;
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0)
        return null;
      else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
        return null;
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options))
        return null;
      if (lt && !satisfies(eq, String(lt), options))
        return null;
      for (const c of dom) {
        if (!satisfies(eq, String(c), options))
          return false;
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c)
            return false;
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
          return false;
      }
      if (lt) {
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c)
            return false;
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
          return false;
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0)
        return false;
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0)
      return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0)
      return false;
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a)
      return b;
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a)
      return b;
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module2.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports2, module2) => {
  var internalRe = require_re();
  module2.exports = {
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
    SemVer: require_semver(),
    compareIdentifiers: require_identifiers().compareIdentifiers,
    rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
    parse: require_parse(),
    valid: require_valid(),
    clean: require_clean(),
    inc: require_inc(),
    diff: require_diff(),
    major: require_major(),
    minor: require_minor(),
    patch: require_patch(),
    prerelease: require_prerelease(),
    compare: require_compare(),
    rcompare: require_rcompare(),
    compareLoose: require_compare_loose(),
    compareBuild: require_compare_build(),
    sort: require_sort(),
    rsort: require_rsort(),
    gt: require_gt(),
    lt: require_lt(),
    eq: require_eq(),
    neq: require_neq(),
    gte: require_gte(),
    lte: require_lte(),
    cmp: require_cmp(),
    coerce: require_coerce(),
    Comparator: require_comparator(),
    Range: require_range(),
    satisfies: require_satisfies(),
    toComparators: require_to_comparators(),
    maxSatisfying: require_max_satisfying(),
    minSatisfying: require_min_satisfying(),
    minVersion: require_min_version(),
    validRange: require_valid2(),
    outside: require_outside(),
    gtr: require_gtr(),
    ltr: require_ltr(),
    intersects: require_intersects(),
    simplifyRange: require_simplify(),
    subset: require_subset()
  };
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs5 = require("fs");
  function checkPathExt(path8, options) {
    var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path8.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path8, options) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path8, options);
  }
  function isexe(path8, options, cb) {
    fs5.stat(path8, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path8, options));
    });
  }
  function sync(path8, options) {
    return checkStat(fs5.statSync(path8), path8, options);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs5 = require("fs");
  function isexe(path8, options, cb) {
    fs5.stat(path8, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options));
    });
  }
  function sync(path8, options) {
    return checkStat(fs5.statSync(path8), options);
  }
  function checkStat(stat, options) {
    return stat.isFile() && checkMode(stat, options);
  }
  function checkMode(stat, options) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
    var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs5 = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path8, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path8, options || {}, function(er, is2) {
          if (er) {
            reject(er);
          } else {
            resolve(is2);
          }
        });
      });
    }
    core(path8, options || {}, function(er, is2) {
      if (er) {
        if (er.code === "EACCES" || options && options.ignoreErrors) {
          er = null;
          is2 = false;
        }
      }
      cb(er, is2);
    });
  }
  function sync(path8, options) {
    try {
      return core.sync(path8, options || {});
    } catch (er) {
      if (options && options.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path8 = require("path");
  var COLON = isWindows ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows ? pathExtExe.split(colon) : [""];
    if (isWindows) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which2 = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path8.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is2) => {
        if (!er && is2) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path8.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is2 = isexe.sync(cur, {pathExt: pathExtExe});
          if (is2) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which2;
  which2.sync = whichSync;
});

// src/index.ts
__export(exports, {
  activate: () => activate
});
var import_coc33 = __toModule(require("coc.nvim"));

// src/server/index.ts
var import_coc31 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol23 = __toModule(require_main3());

// src/server/typescriptServiceClientHost.ts
var import_coc30 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol22 = __toModule(require_main3());

// src/utils/arrays.ts
function equals(one, other, itemEquals = (a, b) => a === b) {
  if (one.length !== other.length) {
    return false;
  }
  for (let i = 0, len = one.length; i < len; i++) {
    if (!itemEquals(one[i], other[i])) {
      return false;
    }
  }
  return true;
}
function flatten(arr) {
  return [].concat.apply([], arr);
}

// src/server/features/fileConfigurationManager.ts
var import_coc = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol = __toModule(require_main3());

// src/server/utils/api.ts
var semver = __toModule(require_semver2());
var API2 = class {
  constructor(versionString, version) {
    this.versionString = versionString;
    this.version = version;
  }
  static fromSimpleString(value) {
    return new API2(value, value);
  }
  static fromVersionString(versionString) {
    let version = semver.valid(versionString);
    if (!version) {
      return new API2("invalid version", "1.0.0");
    }
    const index = versionString.indexOf("-");
    if (index >= 0) {
      version = version.substr(0, index);
    }
    return new API2(versionString, version);
  }
  gte(other) {
    return semver.gte(this.version, other.version);
  }
  lt(other) {
    return !this.gte(other);
  }
};
var API = API2;
API.defaultVersion = API2.fromSimpleString("1.0.0");
API.v203 = API2.fromSimpleString("2.0.3");
API.v206 = API2.fromSimpleString("2.0.6");
API.v208 = API2.fromSimpleString("2.0.8");
API.v213 = API2.fromSimpleString("2.1.3");
API.v220 = API2.fromSimpleString("2.2.0");
API.v222 = API2.fromSimpleString("2.2.2");
API.v230 = API2.fromSimpleString("2.3.0");
API.v234 = API2.fromSimpleString("2.3.4");
API.v240 = API2.fromSimpleString("2.4.0");
API.v250 = API2.fromSimpleString("2.5.0");
API.v260 = API2.fromSimpleString("2.6.0");
API.v270 = API2.fromSimpleString("2.7.0");
API.v280 = API2.fromSimpleString("2.8.0");
API.v290 = API2.fromSimpleString("2.9.0");
API.v291 = API2.fromSimpleString("2.9.1");
API.v292 = API2.fromSimpleString("2.9.2");
API.v300 = API2.fromSimpleString("3.0.0");
API.v310 = API2.fromSimpleString("3.1.0");
API.v314 = API2.fromSimpleString("3.1.4");
API.v320 = API2.fromSimpleString("3.2.0");
API.v330 = API2.fromSimpleString("3.3.0");
API.v333 = API2.fromSimpleString("3.3.3");
API.v340 = API2.fromSimpleString("3.4.0");
API.v345 = API2.fromSimpleString("3.4.5");
API.v350 = API2.fromSimpleString("3.5.0");
API.v380 = API2.fromSimpleString("3.8.0");
API.v381 = API2.fromSimpleString("3.8.1");
API.v390 = API2.fromSimpleString("3.9.0");
API.v400 = API2.fromSimpleString("4.0.0");
API.v401 = API2.fromSimpleString("4.0.1");
var api_default = API;

// src/server/features/fileConfigurationManager.ts
function objAreEqual(a, b) {
  let keys = Object.keys(a);
  for (let i = 0; i < keys.length; i++) {
    let key = keys[i];
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
var FileConfigurationManager = class {
  constructor(client) {
    this.client = client;
    this.cachedMap = new Map();
    this.disposables = [];
    import_coc.workspace.onDidCloseTextDocument((textDocument) => {
      this.cachedMap.delete(textDocument.uri);
    }, void 0, this.disposables);
  }
  async ensureConfigurationOptions(document, insertSpaces, tabSize, token) {
    const file2 = this.client.toPath(document.uri);
    let options = {
      tabSize,
      insertSpaces
    };
    let cachedOption = this.cachedMap.get(document.uri);
    const currentOptions = this.getFileOptions(options, document);
    if (cachedOption && objAreEqual(cachedOption.formatOptions, currentOptions.formatOptions) && objAreEqual(cachedOption.preferences, currentOptions.preferences))
      return;
    this.cachedMap.set(document.uri, currentOptions);
    const args = {
      file: file2,
      ...currentOptions
    };
    await this.client.execute("configure", args, import_vscode_languageserver_protocol.CancellationToken.None);
    try {
      const response = await this.client.execute("configure", args, token);
      if (response.type !== "response") {
        this.cachedMap.delete(document.uri);
      }
    } catch (_e) {
      this.cachedMap.delete(document.uri);
    }
  }
  async ensureConfigurationForDocument(document, token) {
    let opts = await import_coc.workspace.getFormatOptions(document.uri);
    return this.ensureConfigurationOptions(document, opts.insertSpaces, opts.tabSize, token);
  }
  reset() {
    this.cachedMap.clear();
  }
  getLanguageConfiguration(languageId) {
    return import_coc.workspace.getConfiguration(languageId);
  }
  isTypeScriptDocument(languageId) {
    return languageId.startsWith("typescript");
  }
  formatEnabled(document) {
    let {languageId, uri} = document;
    let language = languageId.startsWith("typescript") ? "typescript" : "javascript";
    const config = import_coc.workspace.getConfiguration(`${language}.format`, uri);
    return config.get("enabled");
  }
  enableJavascript() {
    const config = import_coc.workspace.getConfiguration("tsserver");
    return !!config.get("enableJavascript");
  }
  getFileOptions(options, document) {
    const lang = this.isTypeScriptDocument(document.languageId) ? "typescript" : "javascript";
    return {
      formatOptions: this.getFormatOptions(options, lang, document.uri),
      preferences: this.getPreferences(lang, document.uri)
    };
  }
  getFormatOptions(options, language, uri) {
    const config = import_coc.workspace.getConfiguration(`${language}.format`, uri);
    return {
      tabSize: options.tabSize,
      indentSize: options.tabSize,
      convertTabsToSpaces: options.insertSpaces,
      newLineCharacter: "\n",
      insertSpaceAfterCommaDelimiter: config.get("insertSpaceAfterCommaDelimiter"),
      insertSpaceAfterConstructor: config.get("insertSpaceAfterConstructor"),
      insertSpaceAfterSemicolonInForStatements: config.get("insertSpaceAfterSemicolonInForStatements"),
      insertSpaceBeforeAndAfterBinaryOperators: config.get("insertSpaceBeforeAndAfterBinaryOperators"),
      insertSpaceAfterKeywordsInControlFlowStatements: config.get("insertSpaceAfterKeywordsInControlFlowStatements"),
      insertSpaceAfterFunctionKeywordForAnonymousFunctions: config.get("insertSpaceAfterFunctionKeywordForAnonymousFunctions"),
      insertSpaceBeforeFunctionParenthesis: config.get("insertSpaceBeforeFunctionParenthesis"),
      insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: config.get("insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis"),
      insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: config.get("insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets"),
      insertSpaceAfterOpeningAndBeforeClosingEmptyBraces: config.get("insertSpaceAfterOpeningAndBeforeClosingEmptyBraces"),
      insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: config.get("insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces"),
      insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: config.get("insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces"),
      insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: config.get("insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces"),
      insertSpaceAfterTypeAssertion: config.get("insertSpaceAfterTypeAssertion"),
      placeOpenBraceOnNewLineForFunctions: config.get("placeOpenBraceOnNewLineForFunctions"),
      placeOpenBraceOnNewLineForControlBlocks: config.get("placeOpenBraceOnNewLineForControlBlocks"),
      semicolons: config.get("semicolons", void 0)
    };
  }
  getCompleteOptions(languageId) {
    const lang = this.isTypeScriptDocument(languageId) ? "typescript" : "javascript";
    const config = import_coc.workspace.getConfiguration(`${lang}.suggest`);
    return {
      enabled: config.get("enabled", true),
      names: config.get("names", true),
      paths: config.get("paths", true),
      completeFunctionCalls: config.get("completeFunctionCalls", true),
      autoImports: config.get("autoImports", true),
      includeAutomaticOptionalChainCompletions: config.get("includeAutomaticOptionalChainCompletions", true)
    };
  }
  getPreferences(language, uri) {
    if (this.client.apiVersion.lt(api_default.v290)) {
      return {};
    }
    const config = import_coc.workspace.getConfiguration(`${language}.preferences`, uri);
    const preferences = {
      quotePreference: this.getQuoteStyle(config),
      importModuleSpecifierPreference: getImportModuleSpecifier(config),
      importModuleSpecifierEnding: getImportModuleSpecifierEndingPreference(config),
      allowTextChangesInNewFiles: uri.startsWith("file:"),
      allowRenameOfImportPath: true,
      providePrefixAndSuffixTextForRename: config.get("renameShorthandProperties", true) === false ? false : config.get("useAliasesForRenames", true)
    };
    return preferences;
  }
  getQuoteStyle(config) {
    let quoteStyle = config.get("quoteStyle", "auto");
    if (this.client.apiVersion.gte(api_default.v333) || quoteStyle != "auto")
      return quoteStyle;
    return "single";
  }
  dispose() {
    import_coc.disposeAll(this.disposables);
  }
};
var fileConfigurationManager_default = FileConfigurationManager;
function getImportModuleSpecifier(config) {
  let val = config.get("importModuleSpecifier");
  switch (val) {
    case "relative":
      return "relative";
    case "non-relative":
      return "non-relative";
    default:
      return "auto";
  }
}
function getImportModuleSpecifierEndingPreference(config) {
  switch (config.get("importModuleSpecifierEnding")) {
    case "minimal":
      return "minimal";
    case "index":
      return "index";
    case "js":
      return "js";
    default:
      return "auto";
  }
}

// src/server/features/watchBuild.ts
var import_coc2 = __toModule(require("coc.nvim"));
var import_path = __toModule(require("path"));
var import_vscode_languageserver_protocol2 = __toModule(require_main3());
var countRegex = /Found\s+(\d+)\s+error/;
var errorRegex = /^(.+)\((\d+),(\d+)\):\s(\w+)\sTS(\d+):\s*(.+)$/;
var TscStatus;
(function(TscStatus2) {
  TscStatus2[TscStatus2["INIT"] = 0] = "INIT";
  TscStatus2[TscStatus2["COMPILING"] = 1] = "COMPILING";
  TscStatus2[TscStatus2["RUNNING"] = 2] = "RUNNING";
  TscStatus2[TscStatus2["ERROR"] = 3] = "ERROR";
})(TscStatus || (TscStatus = {}));
var WatchProject2 = class {
  constructor(client) {
    this.client = client;
    this.disposables = [];
    this.statusItem = import_coc2.window.createStatusBarItem(1, {progress: true});
    let task = this.task = import_coc2.workspace.createTask("TSC");
    this.disposables.push(import_coc2.commands.registerCommand(WatchProject2.id, async () => {
      let opts = this.options = await this.getOptions();
      await this.start(opts);
    }));
    task.onExit((code) => {
      if (code != 0) {
        import_coc2.window.showMessage(`TSC exit with code ${code}`, "warning");
      }
      this.onStop();
    });
    task.onStdout((lines) => {
      for (let line of lines) {
        this.onLine(line);
      }
    });
    task.onStderr((lines) => {
      import_coc2.window.showMessage(`TSC error: ` + lines.join("\n"), "error");
    });
    this.disposables.push(import_vscode_languageserver_protocol2.Disposable.create(() => {
      task.dispose();
    }));
    this.check().catch((_e) => {
    });
  }
  async check() {
    let running = await this.task.running;
    if (running) {
      this.options = await this.getOptions();
      this.statusItem.isProgress = false;
      this.statusItem.text = "?";
      this.statusItem.show();
    } else {
      this.onStop();
    }
  }
  async start(options) {
    await this.task.start(options);
  }
  onStop() {
    this.statusItem.hide();
  }
  onStart() {
    this.statusItem.text = "compiling";
    this.statusItem.isProgress = true;
    this.statusItem.show();
    import_coc2.workspace.nvim.call("setqflist", [[]], true);
  }
  onLine(line) {
    if (countRegex.test(line)) {
      let ms = line.match(countRegex);
      this.statusItem.text = ms[1] == "0" ? "\u2713" : "\u2717";
      this.statusItem.isProgress = false;
    } else if (WatchProject2.startTexts.findIndex((s) => line.indexOf(s) !== -1) != -1) {
      this.onStart();
    } else {
      let ms = line.match(errorRegex);
      if (!ms)
        return;
      let fullpath = import_path.default.join(this.options.cwd, ms[1]);
      let uri = import_coc2.Uri.file(fullpath).toString();
      let doc = import_coc2.workspace.getDocument(uri);
      let bufnr = doc ? doc.bufnr : null;
      let item = {
        filename: fullpath,
        lnum: Number(ms[2]),
        col: Number(ms[3]),
        text: `[tsc ${ms[5]}] ${ms[6]}`,
        type: /error/i.test(ms[4]) ? "E" : "W"
      };
      if (bufnr)
        item.bufnr = bufnr;
      import_coc2.workspace.nvim.call("setqflist", [[item], "a"]);
    }
  }
  async getOptions() {
    let {tscPath} = this.client;
    if (!tscPath) {
      import_coc2.window.showMessage(`Local & global tsc not found`, "error");
      return;
    }
    let find = await import_coc2.workspace.findUp(["tsconfig.json"]);
    if (!find) {
      import_coc2.window.showMessage("tsconfig.json not found!", "error");
      return;
    }
    let root = import_path.default.dirname(find);
    return {
      cmd: tscPath,
      args: ["-p", "tsconfig.json", "--watch", "true", "--pretty", "false"],
      cwd: root
    };
  }
  dispose() {
    import_coc2.disposeAll(this.disposables);
  }
};
var WatchProject = WatchProject2;
WatchProject.id = "tsserver.watchBuild";
WatchProject.startTexts = ["Starting compilation in watch mode", "Starting incremental compilation"];
var watchBuild_default = WatchProject;

// src/server/features/workspaceSymbols.ts
var import_coc3 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol3 = __toModule(require_main3());

// src/server/utils/typeConverters.ts
var Range;
(function(Range16) {
  Range16.fromTextSpan = (span) => {
    return {
      start: {
        line: span.start.line - 1,
        character: span.start.offset - 1
      },
      end: {
        line: span.end.line - 1,
        character: span.end.offset - 1
      }
    };
  };
  Range16.toFormattingRequestArgs = (file2, range) => ({
    file: file2,
    line: range.start.line + 1,
    offset: range.start.character + 1,
    endLine: range.end.line + 1,
    endOffset: range.end.character + 1
  });
  Range16.toFileRangeRequestArgs = (file2, range) => ({
    file: file2,
    startLine: range.start.line + 1,
    startOffset: range.start.character + 1,
    endLine: range.end.line + 1,
    endOffset: range.end.character + 1
  });
})(Range || (Range = {}));
var Position;
(function(Position8) {
  Position8.fromLocation = (tslocation) => {
    return {
      line: tslocation.line - 1,
      character: tslocation.offset - 1
    };
  };
  Position8.toLocation = (position) => ({
    line: position.line + 1,
    offset: position.character + 1
  });
  Position8.toFileLocationRequestArgs = (file2, position) => ({
    file: file2,
    line: position.line + 1,
    offset: position.character + 1
  });
})(Position || (Position = {}));
var Location2;
(function(Location3) {
  Location3.fromTextSpan = (uri, tsTextSpan) => {
    return {
      uri,
      range: Range.fromTextSpan(tsTextSpan)
    };
  };
})(Location2 || (Location2 = {}));
var TextEdit;
(function(TextEdit6) {
  TextEdit6.fromCodeEdit = (edit) => {
    return {
      range: Range.fromTextSpan(edit),
      newText: edit.newText
    };
  };
})(TextEdit || (TextEdit = {}));
var WorkspaceEdit;
(function(WorkspaceEdit6) {
  function fromFileCodeEdits(client, edits) {
    let changes = {};
    for (const edit of edits) {
      let uri = client.toResource(edit.fileName);
      changes[uri] = edit.textChanges.map((change) => {
        return TextEdit.fromCodeEdit(change);
      });
    }
    return {changes};
  }
  WorkspaceEdit6.fromFileCodeEdits = fromFileCodeEdits;
})(WorkspaceEdit || (WorkspaceEdit = {}));

// src/server/features/workspaceSymbols.ts
function getSymbolKind(item) {
  switch (item.kind) {
    case "method":
      return import_vscode_languageserver_protocol3.SymbolKind.Method;
    case "enum":
      return import_vscode_languageserver_protocol3.SymbolKind.Enum;
    case "function":
      return import_vscode_languageserver_protocol3.SymbolKind.Function;
    case "class":
      return import_vscode_languageserver_protocol3.SymbolKind.Class;
    case "interface":
      return import_vscode_languageserver_protocol3.SymbolKind.Interface;
    case "var":
      return import_vscode_languageserver_protocol3.SymbolKind.Variable;
    default:
      return import_vscode_languageserver_protocol3.SymbolKind.Variable;
  }
}
var TypeScriptWorkspaceSymbolProvider = class {
  constructor(client, languageIds) {
    this.client = client;
    this.languageIds = languageIds;
  }
  async provideWorkspaceSymbols(search, token) {
    let filepath;
    if (this.searchAllOpenProjects) {
      filepath = void 0;
    } else {
      let uri = this.getUri();
      filepath = uri ? this.client.toPath(uri) : void 0;
      if (!filepath && this.client.apiVersion.lt(api_default.v390)) {
        return [];
      }
    }
    const args = {
      file: filepath,
      searchValue: search,
      maxResultCount: 256
    };
    const response = await this.client.execute("navto", args, token);
    if (response.type !== "response" || response.body == null)
      return [];
    const result = [];
    for (const item of response.body) {
      if (!item.containerName && item.kind === "alias") {
        continue;
      }
      const label = TypeScriptWorkspaceSymbolProvider.getLabel(item);
      const range = {
        start: Position.fromLocation(item.start),
        end: Position.fromLocation(item.end)
      };
      const symbolInfo = import_vscode_languageserver_protocol3.SymbolInformation.create(label, getSymbolKind(item), range, this.client.toResource(item.file));
      result.push(symbolInfo);
    }
    return result;
  }
  static getLabel(item) {
    let label = item.name;
    if (item.kind === "method" || item.kind === "function") {
      label += "()";
    }
    return label;
  }
  getUri() {
    const documents = import_coc3.workspace.textDocuments;
    for (const document of documents) {
      if (this.languageIds.indexOf(document.languageId) >= 0) {
        return document.uri;
      }
    }
    return void 0;
  }
  get searchAllOpenProjects() {
    return this.client.apiVersion.gte(api_default.v390) && import_coc3.workspace.getConfiguration("typescript").get("workspaceSymbols.scope", "allOpenProjects") === "allOpenProjects";
  }
};
var workspaceSymbols_default = TypeScriptWorkspaceSymbolProvider;

// src/server/languageProvider.ts
var import_coc19 = __toModule(require("coc.nvim"));
var import_path4 = __toModule(require("path"));
var import_vscode_languageserver_protocol18 = __toModule(require_main3());

// src/server/features/baseCodeLensProvider.ts
var import_vscode_languageserver_protocol4 = __toModule(require_main3());

// src/server/utils/regexp.ts
function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}

// src/server/features/baseCodeLensProvider.ts
var CachedNavTreeResponse = class {
  constructor() {
    this.version = -1;
    this.document = "";
  }
  execute(document, f) {
    if (this.matches(document)) {
      return this.response;
    }
    return this.update(document, f());
  }
  matches(document) {
    return this.version === document.version && this.document === document.uri.toString();
  }
  update(document, response) {
    this.response = response;
    this.version = document.version;
    this.document = document.uri.toString();
    return response;
  }
};
var TypeScriptBaseCodeLensProvider = class {
  constructor(client, cachedResponse) {
    this.client = client;
    this.cachedResponse = cachedResponse;
    this.onDidChangeCodeLensesEmitter = new import_vscode_languageserver_protocol4.Emitter();
  }
  get onDidChangeCodeLenses() {
    return this.onDidChangeCodeLensesEmitter.event;
  }
  async provideCodeLenses(document, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath) {
      return [];
    }
    try {
      const response = await this.cachedResponse.execute(document, () => this.client.execute("navtree", {file: filepath}, token));
      if (!response) {
        return [];
      }
      const tree = response.body;
      const referenceableSpans = [];
      if (tree && tree.childItems) {
        tree.childItems.forEach((item) => this.walkNavTree(document, item, null, referenceableSpans));
      }
      return referenceableSpans.map((range) => {
        return {
          range,
          data: {uri: document.uri}
        };
      });
    } catch {
      return [];
    }
  }
  walkNavTree(document, item, parent, results) {
    if (!item) {
      return;
    }
    const range = this.extractSymbol(document, item, parent);
    if (range) {
      results.push(range);
    }
    if (item.childItems) {
      item.childItems.forEach((child) => this.walkNavTree(document, child, item, results));
    }
  }
  getSymbolRange(document, item) {
    if (!item) {
      return null;
    }
    if (item.nameSpan) {
      return Range.fromTextSpan(item.nameSpan);
    }
    const span = item.spans && item.spans[0];
    if (!span) {
      return null;
    }
    const range = Range.fromTextSpan(span);
    const text = document.getText(range);
    const identifierMatch = new RegExp(`^(.*?(\\b|\\W))${escapeRegExp(item.text || "")}(\\b|\\W)`, "gm");
    const match = identifierMatch.exec(text);
    const prefixLength = match ? match.index + match[1].length : 0;
    const startOffset = document.offsetAt(range.start) + prefixLength;
    return {
      start: document.positionAt(startOffset),
      end: document.positionAt(startOffset + item.text.length)
    };
  }
};

// src/server/features/completionItemProvider.ts
var import_coc5 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol8 = __toModule(require_main3());

// src/server/protocol.const.ts
var Kind = class {
};
Kind.alias = "alias";
Kind.callSignature = "call";
Kind.class = "class";
Kind.const = "const";
Kind.constructorImplementation = "constructor";
Kind.constructSignature = "construct";
Kind.directory = "directory";
Kind.enum = "enum";
Kind.enumMember = "enum member";
Kind.externalModuleName = "external module name";
Kind.function = "function";
Kind.indexSignature = "index";
Kind.interface = "interface";
Kind.keyword = "keyword";
Kind.let = "let";
Kind.localFunction = "local function";
Kind.localVariable = "local var";
Kind.method = "method";
Kind.memberGetAccessor = "getter";
Kind.memberSetAccessor = "setter";
Kind.memberVariable = "property";
Kind.module = "module";
Kind.primitiveType = "primitive type";
Kind.script = "script";
Kind.type = "type";
Kind.variable = "var";
Kind.warning = "warning";
Kind.string = "string";
Kind.parameter = "parameter";
Kind.typeParameter = "type parameter";
var DiagnosticCategory = class {
};
DiagnosticCategory.error = "error";
DiagnosticCategory.warning = "warning";
DiagnosticCategory.suggestion = "suggestion";
var KindModifiers2 = class {
};
var KindModifiers = KindModifiers2;
KindModifiers.optional = "optional";
KindModifiers.color = "color";
KindModifiers.dtsFile = ".d.ts";
KindModifiers.tsFile = ".ts";
KindModifiers.tsxFile = ".tsx";
KindModifiers.jsFile = ".js";
KindModifiers.jsxFile = ".jsx";
KindModifiers.jsonFile = ".json";
KindModifiers.fileExtensionKindModifiers = [
  KindModifiers2.dtsFile,
  KindModifiers2.tsFile,
  KindModifiers2.tsxFile,
  KindModifiers2.jsFile,
  KindModifiers2.jsxFile,
  KindModifiers2.jsonFile
];
var DisplayPartKind = class {
};
DisplayPartKind.functionName = "functionName";
DisplayPartKind.methodName = "methodName";
DisplayPartKind.parameterName = "parameterName";
DisplayPartKind.propertyName = "propertyName";
DisplayPartKind.punctuation = "punctuation";
DisplayPartKind.text = "text";

// src/server/utils/codeAction.ts
var import_vscode_languageserver_protocol5 = __toModule(require_main3());
var import_coc4 = __toModule(require("coc.nvim"));
function getEditForCodeAction(client, action) {
  return action.changes && action.changes.length ? WorkspaceEdit.fromFileCodeEdits(client, action.changes) : void 0;
}
async function applyCodeAction(client, action) {
  const workspaceEdit = getEditForCodeAction(client, action);
  if (workspaceEdit) {
    if (!await import_coc4.workspace.applyEdit(workspaceEdit)) {
      return false;
    }
  }
  return applyCodeActionCommands(client, action);
}
async function applyCodeActionCommands(client, action) {
  if (action.commands && action.commands.length) {
    for (const command of action.commands) {
      const response = await client.execute("applyCodeActionCommand", {command}, import_vscode_languageserver_protocol5.CancellationToken.None);
      if (!response || response.type != "response" || !response.body) {
        return false;
      }
    }
  }
  return true;
}

// src/server/utils/completionItem.ts
var import_vscode_languageserver_protocol6 = __toModule(require_main3());
function convertCompletionEntry(tsEntry, uri, position, context) {
  let label = tsEntry.name;
  let sortText = tsEntry.sortText;
  let preselect = false;
  let detail;
  if (tsEntry.isRecommended) {
    preselect = true;
  }
  if (tsEntry.source) {
    sortText = "\uFFFF" + sortText;
  } else {
    sortText = tsEntry.sortText;
  }
  let kind = convertKind(tsEntry.kind);
  let insertTextFormat = context.enableCallCompletions && (kind === import_vscode_languageserver_protocol6.CompletionItemKind.Function || kind === import_vscode_languageserver_protocol6.CompletionItemKind.Method) ? import_vscode_languageserver_protocol6.InsertTextFormat.Snippet : import_vscode_languageserver_protocol6.InsertTextFormat.PlainText;
  let insertText = tsEntry.insertText;
  let commitCharacters = getCommitCharacters(tsEntry, context);
  let textEdit = null;
  if (tsEntry.replacementSpan) {
    let {start, end} = tsEntry.replacementSpan;
    if (start.line == end.line) {
      textEdit = {
        range: import_vscode_languageserver_protocol6.Range.create(start.line - 1, start.offset - 1, end.line - 1, end.offset - 1),
        newText: insertText || label
      };
    }
  }
  if (tsEntry.kindModifiers) {
    const kindModifiers = new Set(tsEntry.kindModifiers.split(/,|\s+/g));
    if (kindModifiers.has(KindModifiers.optional)) {
      insertText = label;
      label += "?";
    }
    if (kindModifiers.has(KindModifiers.color)) {
      kind = import_vscode_languageserver_protocol6.CompletionItemKind.Color;
    }
    if (tsEntry.kind === Kind.script) {
      for (const extModifier of KindModifiers.fileExtensionKindModifiers) {
        if (kindModifiers.has(extModifier)) {
          if (tsEntry.name.toLowerCase().endsWith(extModifier)) {
            detail = tsEntry.name;
          } else {
            detail = tsEntry.name + extModifier;
          }
          break;
        }
      }
    }
  }
  return {
    label,
    insertText,
    textEdit,
    kind,
    preselect,
    insertTextFormat,
    sortText,
    commitCharacters,
    detail,
    data: {
      uri,
      position,
      name: tsEntry.name,
      source: tsEntry.source || ""
    }
  };
}
function convertKind(kind) {
  switch (kind) {
    case Kind.primitiveType:
    case Kind.keyword:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Keyword;
    case Kind.const:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Constant;
    case Kind.let:
    case Kind.variable:
    case Kind.localVariable:
    case Kind.alias:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Variable;
    case Kind.memberVariable:
    case Kind.memberGetAccessor:
    case Kind.memberSetAccessor:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Field;
    case Kind.function:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Function;
    case Kind.method:
    case Kind.constructSignature:
    case Kind.callSignature:
    case Kind.indexSignature:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Method;
    case Kind.enum:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Enum;
    case Kind.module:
    case Kind.externalModuleName:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Module;
    case Kind.class:
    case Kind.type:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Class;
    case Kind.interface:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Interface;
    case Kind.warning:
    case Kind.script:
      return import_vscode_languageserver_protocol6.CompletionItemKind.File;
    case Kind.directory:
      return import_vscode_languageserver_protocol6.CompletionItemKind.Folder;
  }
  return import_vscode_languageserver_protocol6.CompletionItemKind.Variable;
}
function getCommitCharacters(tsEntry, context) {
  if (context.isNewIdentifierLocation || !context.isInValidCommitCharacterContext) {
    return void 0;
  }
  const commitCharacters = [];
  switch (tsEntry.kind) {
    case Kind.memberGetAccessor:
    case Kind.memberSetAccessor:
    case Kind.constructSignature:
    case Kind.callSignature:
    case Kind.indexSignature:
    case Kind.enum:
    case Kind.interface:
      commitCharacters.push(".", ";");
      break;
    case Kind.module:
    case Kind.alias:
    case Kind.const:
    case Kind.let:
    case Kind.variable:
    case Kind.localVariable:
    case Kind.memberVariable:
    case Kind.class:
    case Kind.function:
    case Kind.method:
    case Kind.keyword:
    case Kind.parameter:
      commitCharacters.push(".", ",", ";");
      if (context.enableCallCompletions) {
        commitCharacters.push("(");
      }
      break;
  }
  return commitCharacters.length === 0 ? void 0 : commitCharacters;
}
function getParameterListParts(displayParts) {
  const parts = [];
  let isInMethod = false;
  let hasOptionalParameters = false;
  let parenCount = 0;
  let braceCount = 0;
  outer:
    for (let i = 0; i < displayParts.length; ++i) {
      const part = displayParts[i];
      switch (part.kind) {
        case DisplayPartKind.methodName:
        case DisplayPartKind.functionName:
        case DisplayPartKind.text:
        case DisplayPartKind.propertyName:
          if (parenCount === 0 && braceCount === 0) {
            isInMethod = true;
          }
          break;
        case DisplayPartKind.parameterName:
          if (parenCount === 1 && braceCount === 0 && isInMethod) {
            const next = displayParts[i + 1];
            const nameIsFollowedByOptionalIndicator = next && next.text === "?";
            const nameIsThis = part.text === "this";
            if (!nameIsFollowedByOptionalIndicator && !nameIsThis) {
              parts.push(part);
            }
            hasOptionalParameters = hasOptionalParameters || nameIsFollowedByOptionalIndicator;
          }
          break;
        case DisplayPartKind.punctuation:
          if (part.text === "(") {
            ++parenCount;
          } else if (part.text === ")") {
            --parenCount;
            if (parenCount <= 0 && isInMethod) {
              break outer;
            }
          } else if (part.text === "..." && parenCount === 1) {
            hasOptionalParameters = true;
            break outer;
          } else if (part.text === "{") {
            ++braceCount;
          } else if (part.text === "}") {
            --braceCount;
          }
          break;
      }
    }
  return {hasOptionalParameters, parts};
}

// src/server/utils/previewer.ts
var import_vscode_languageserver_protocol7 = __toModule(require_main3());
function getTagBodyText(tag) {
  if (!tag.text) {
    return void 0;
  }
  switch (tag.name) {
    case "example":
    case "default":
      if (tag.text.match(/^\s*[~`]{3}/g)) {
        return tag.text;
      }
      return "```\n" + tag.text + "\n```";
  }
  return tag.text;
}
function getTagDocumentation(tag) {
  switch (tag.name) {
    case "param":
      const body = (tag.text || "").split(/^([\w\.]+)\s*/);
      if (body && body.length === 3) {
        const param = body[1];
        const doc = body[2];
        const label2 = `*@${tag.name}* \`${param}\``;
        if (!doc) {
          return label2;
        }
        return label2 + (doc.match(/\r\n|\n/g) ? "\n" + doc : ` \u2014 ${doc}`);
      }
  }
  const label = `*@${tag.name}*`;
  const text = getTagBodyText(tag);
  if (!text) {
    return label;
  }
  return label + (text.match(/\r\n|\n/g) ? "\n" + text : ` \u2014 ${text}`);
}
function plain(parts) {
  if (!parts || !parts.length)
    return "";
  return parts.map((part) => part.text).join("");
}
function tagsMarkdownPreview(tags) {
  return (tags || []).map(getTagDocumentation).join("  \n\n");
}
function markdownDocumentation(documentation, tags) {
  let out = plain(documentation);
  const tagsPreview = tagsMarkdownPreview(tags);
  if (tagsPreview) {
    out = out + ("\n\n" + tagsPreview);
  }
  return {
    kind: import_vscode_languageserver_protocol7.MarkupKind.Markdown,
    value: out
  };
}

// src/server/utils/SnippetString.ts
var SnippetString = class {
  constructor(value) {
    this._tabstop = 1;
    this.value = value || "";
  }
  static isSnippetString(thing) {
    if (thing instanceof SnippetString) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return typeof thing.value === "string";
  }
  static _escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  appendText(str) {
    this.value += SnippetString._escape(str);
    return this;
  }
  appendTabstop(n = this._tabstop++) {
    this.value += "$";
    this.value += n;
    return this;
  }
  appendPlaceholder(value, n = this._tabstop++) {
    if (typeof value === "function") {
      const nested = new SnippetString();
      nested._tabstop = this._tabstop;
      value(nested);
      this._tabstop = nested._tabstop;
      value = nested.value;
    } else {
      value = SnippetString._escape(value);
    }
    this.value += "${";
    this.value += n;
    this.value += ":";
    this.value += value;
    this.value += "}";
    return this;
  }
  appendVariable(name, defaultValue) {
    if (typeof defaultValue === "function") {
      const nested = new SnippetString();
      nested._tabstop = this._tabstop;
      defaultValue(nested);
      this._tabstop = nested._tabstop;
      defaultValue = nested.value;
    } else if (typeof defaultValue === "string") {
      defaultValue = defaultValue.replace(/\$|}/g, "\\$&");
    }
    this.value += "${";
    this.value += name;
    if (defaultValue) {
      this.value += ":";
      this.value += defaultValue;
    }
    this.value += "}";
    return this;
  }
};
var SnippetString_default = SnippetString;

// src/server/features/completionItemProvider.ts
var ApplyCompletionCodeActionCommand2 = class {
  constructor(client) {
    this.client = client;
    this.id = ApplyCompletionCodeActionCommand2.ID;
  }
  async execute(codeActions) {
    if (codeActions.length === 0) {
      return;
    }
    if (codeActions.length === 1) {
      await applyCodeAction(this.client, codeActions[0]);
      return;
    }
    const idx = await import_coc5.window.showQuickpick(codeActions.map((o) => o.description), "Select code action to apply");
    if (idx < 0)
      return;
    const action = codeActions[idx];
    await applyCodeAction(this.client, action);
    return;
  }
};
var ApplyCompletionCodeActionCommand = ApplyCompletionCodeActionCommand2;
ApplyCompletionCodeActionCommand.ID = "_typescript.applyCompletionCodeAction";
var TypeScriptCompletionItemProvider = class {
  constructor(client, typingsStatus, fileConfigurationManager, languageId) {
    this.client = client;
    this.typingsStatus = typingsStatus;
    this.fileConfigurationManager = fileConfigurationManager;
    this.setCompleteOption(languageId);
    import_coc5.commands.registerCommand(ApplyCompletionCodeActionCommand.ID, async (codeActions) => {
      let cmd = new ApplyCompletionCodeActionCommand(this.client);
      await cmd.execute(codeActions);
    });
    import_coc5.workspace.onDidChangeConfiguration((_e) => {
      this.setCompleteOption(languageId);
    });
  }
  setCompleteOption(languageId) {
    this.completeOption = this.fileConfigurationManager.getCompleteOptions(languageId);
  }
  async provideCompletionItems(document, position, token, context) {
    if (this.typingsStatus.isAcquiringTypings) {
      return Promise.resolve({
        isIncomplete: true,
        items: [{
          label: "Acquiring typings...",
          detail: "Acquiring typings definitions for IntelliSense."
        }]
      });
    }
    let {uri} = document;
    const file2 = this.client.toPath(document.uri);
    if (!file2)
      return null;
    let preText = document.getText({
      start: {line: position.line, character: 0},
      end: position
    });
    let {triggerCharacter, option} = context;
    if (!this.shouldTrigger(triggerCharacter, preText, option)) {
      return null;
    }
    await this.client.interruptGetErr(() => this.fileConfigurationManager.ensureConfigurationForDocument(document, token));
    const {completeOption} = this;
    const args = {
      ...Position.toFileLocationRequestArgs(file2, position),
      includeExternalModuleExports: completeOption.autoImports,
      includeInsertTextCompletions: true,
      triggerCharacter: this.getTsTriggerCharacter(context),
      includeAutomaticOptionalChainCompletions: completeOption.includeAutomaticOptionalChainCompletions
    };
    let entries;
    let dotAccessorContext;
    let isNewIdentifierLocation = true;
    let isMemberCompletion = false;
    let isIncomplete = false;
    const isInValidCommitCharacterContext = this.isInValidCommitCharacterContext(document, position);
    if (this.client.apiVersion.gte(api_default.v300)) {
      try {
        const response = await this.client.interruptGetErr(() => this.client.execute("completionInfo", args, token));
        if (response.type !== "response" || !response.body) {
          return null;
        }
        isNewIdentifierLocation = response.body.isNewIdentifierLocation;
        isMemberCompletion = response.body.isMemberCompletion;
        if (isMemberCompletion) {
          const dotMatch = preText.slice(0, position.character).match(/\??\.\s*$/) || void 0;
          if (dotMatch) {
            const range = import_vscode_languageserver_protocol8.Range.create({
              line: position.line,
              character: position.character - dotMatch.length
            }, position);
            const text = document.getText(range);
            dotAccessorContext = {range, text};
          }
        }
        isIncomplete = response.metadata && response.metadata.isIncomplete;
        entries = response.body.entries;
      } catch (e) {
        if (e.message == "No content available.") {
          return null;
        }
        throw e;
      }
    } else {
      const response = await this.client.interruptGetErr(() => this.client.execute("completions", args, token));
      if (response.type !== "response" || !response.body) {
        return null;
      }
      entries = response.body;
    }
    const completionItems = [];
    for (const element of entries) {
      if (shouldExcludeCompletionEntry(element, completeOption)) {
        continue;
      }
      const item = convertCompletionEntry(element, uri, position, {
        isNewIdentifierLocation,
        isMemberCompletion,
        enableCallCompletions: completeOption.completeFunctionCalls,
        isInValidCommitCharacterContext,
        dotAccessorContext
      });
      completionItems.push(item);
    }
    return {isIncomplete, items: completionItems};
  }
  getTsTriggerCharacter(context) {
    switch (context.triggerCharacter) {
      case "@":
        return this.client.apiVersion.gte(api_default.v310) && this.client.apiVersion.lt(api_default.v320) ? void 0 : "@";
      case "#":
        return this.client.apiVersion.lt(api_default.v381) ? void 0 : "#";
      case ".":
      case '"':
      case "'":
      case "`":
      case "/":
      case "<":
        return context.triggerCharacter;
    }
    return void 0;
  }
  async resolveCompletionItem(item, token) {
    if (item == null)
      return void 0;
    let {uri, position, source, name} = item.data;
    const filepath = this.client.toPath(uri);
    if (!filepath)
      return void 0;
    let document = import_coc5.workspace.getDocument(uri);
    if (!document)
      return void 0;
    const args = {
      ...Position.toFileLocationRequestArgs(filepath, position),
      entryNames: [source ? {name, source} : name]
    };
    let response;
    try {
      response = await this.client.interruptGetErr(() => this.client.execute("completionEntryDetails", args, token));
    } catch {
      return item;
    }
    if (response.type !== "response" || !response.body || !response.body.length) {
      return item;
    }
    const details = response.body;
    if (!details || !details.length || !details[0]) {
      return item;
    }
    const detail = details[0];
    if (!item.detail && detail.displayParts.length) {
      item.detail = plain(detail.displayParts);
    }
    item.documentation = this.getDocumentation(detail);
    const {command, additionalTextEdits} = this.getCodeActions(detail, filepath);
    if (command)
      item.command = command;
    item.additionalTextEdits = additionalTextEdits;
    if (detail && item.insertTextFormat == import_vscode_languageserver_protocol8.InsertTextFormat.Snippet) {
      const shouldCompleteFunction = await this.isValidFunctionCompletionContext(filepath, position, token);
      if (shouldCompleteFunction) {
        this.createSnippetOfFunctionCall(item, detail);
      }
    }
    return item;
  }
  getCodeActions(detail, filepath) {
    if (!detail.codeActions || !detail.codeActions.length) {
      return {};
    }
    const additionalTextEdits = [];
    let hasRemainingCommandsOrEdits = false;
    for (const tsAction of detail.codeActions) {
      if (tsAction.commands) {
        hasRemainingCommandsOrEdits = true;
      }
      if (tsAction.changes) {
        for (const change of tsAction.changes) {
          if (change.fileName === filepath) {
            additionalTextEdits.push(...change.textChanges.map(TextEdit.fromCodeEdit));
          } else {
            hasRemainingCommandsOrEdits = true;
          }
        }
      }
    }
    let command = null;
    if (hasRemainingCommandsOrEdits) {
      command = {
        title: "",
        command: ApplyCompletionCodeActionCommand.ID,
        arguments: [
          detail.codeActions.map((x) => ({
            commands: x.commands,
            description: x.description,
            changes: x.changes.filter((x2) => x2.fileName !== filepath)
          }))
        ]
      };
    }
    return {
      command,
      additionalTextEdits: additionalTextEdits.length ? additionalTextEdits : void 0
    };
  }
  shouldTrigger(triggerCharacter, pre, option) {
    if (triggerCharacter && this.client.apiVersion.lt(api_default.v290)) {
      if (triggerCharacter === "@") {
        if (option.synname && /string/i.test(option.synname)) {
          return true;
        }
        if (!pre.match(/^\s*\*[ ]?@/) && !pre.match(/\/\*\*+[ ]?@/)) {
          return false;
        }
      } else if (triggerCharacter === "<") {
        return false;
      }
    }
    return true;
  }
  getDocumentation(detail) {
    let documentation = "";
    if (detail.source) {
      const importPath = `'${plain(detail.source)}'`;
      const autoImportLabel = `Auto import from ${importPath}`;
      documentation += `${autoImportLabel}
`;
    }
    let parts = [
      plain(detail.documentation),
      tagsMarkdownPreview(detail.tags)
    ];
    parts = parts.filter((s) => s && s.trim() != "");
    documentation += parts.join("\n\n");
    if (documentation.length) {
      return {
        kind: import_vscode_languageserver_protocol8.MarkupKind.Markdown,
        value: documentation
      };
    }
    return void 0;
  }
  createSnippetOfFunctionCall(item, detail) {
    let {displayParts} = detail;
    const parameterListParts = getParameterListParts(displayParts);
    const snippet = new SnippetString_default();
    snippet.appendText(`${item.insertText || item.label}(`);
    appendJoinedPlaceholders(snippet, parameterListParts.parts, ", ");
    if (parameterListParts.hasOptionalParameters) {
      snippet.appendTabstop();
    }
    snippet.appendText(")");
    snippet.appendTabstop(0);
    item.insertText = snippet.value;
  }
  async isValidFunctionCompletionContext(filepath, position, token) {
    try {
      const args = Position.toFileLocationRequestArgs(filepath, position);
      const response = await this.client.execute("quickinfo", args, token);
      if (response.type !== "response") {
        return true;
      }
      const {body} = response;
      switch (body && body.kind) {
        case "var":
        case "let":
        case "const":
        case "alias":
          return false;
        default:
          return true;
      }
    } catch (e) {
      return true;
    }
  }
  isInValidCommitCharacterContext(document, position) {
    if (this.client.apiVersion.lt(api_default.v320)) {
      if (position.character > 1) {
        const preText = document.getText(import_vscode_languageserver_protocol8.Range.create(position.line, 0, position.line, position.character));
        return preText.match(/(\s|^)\.$/ig) === null;
      }
    }
    return true;
  }
};
TypeScriptCompletionItemProvider.triggerCharacters = [".", '"', "'", "`", "/", "@", "<", "#"];
var completionItemProvider_default = TypeScriptCompletionItemProvider;
function shouldExcludeCompletionEntry(element, completionConfiguration) {
  return !completionConfiguration.names && element.kind === Kind.warning || !completionConfiguration.paths && (element.kind === Kind.directory || element.kind === Kind.script || element.kind === Kind.externalModuleName) || !completionConfiguration.autoImports && element.hasAction;
}
function appendJoinedPlaceholders(snippet, parts, joiner) {
  for (let i = 0; i < parts.length; ++i) {
    const paramterPart = parts[i];
    snippet.appendPlaceholder(paramterPart.text);
    if (i !== parts.length - 1) {
      snippet.appendText(joiner);
    }
  }
}

// src/server/features/definitionProvider.ts
var TypeScriptDefinitionProvider = class {
  constructor(client) {
    this.client = client;
  }
  async getSymbolLocations(definitionType, document, position, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath) {
      return void 0;
    }
    const args = Position.toFileLocationRequestArgs(filepath, position);
    try {
      const response = await this.client.execute(definitionType, args, token);
      const locations = response.type == "response" && response.body || [];
      return locations.map((location) => Location2.fromTextSpan(this.client.toResource(location.file), location));
    } catch {
      return [];
    }
  }
  provideDefinition(document, position, token) {
    return this.getSymbolLocations("definition", document, position, token);
  }
  provideTypeDefinition(document, position, token) {
    return this.getSymbolLocations("typeDefinition", document, position, token);
  }
  provideImplementation(document, position, token) {
    return this.getSymbolLocations("implementation", document, position, token);
  }
};
var definitionProvider_default = TypeScriptDefinitionProvider;

// src/server/features/directiveCommentCompletions.ts
var import_vscode_languageserver_protocol9 = __toModule(require_main3());
var import_coc6 = __toModule(require("coc.nvim"));
var tsDirectives = [
  {
    value: "@ts-check",
    description: "Enables semantic checking in a JavaScript file. Must be at the top of a file."
  },
  {
    value: "@ts-nocheck",
    description: "Disables semantic checking in a JavaScript file. Must be at the top of a file."
  },
  {
    value: "@ts-ignore",
    description: "Suppresses @ts-check errors on the next line of a file."
  }
];
var tsDirectives390 = [
  ...tsDirectives,
  {
    value: "@ts-expect-error",
    description: "Suppresses @ts-check errors on the next line of a file, expecting at least one to exist."
  }
];
var DirectiveCommentCompletionProvider = class {
  constructor(client) {
    this.client = client;
  }
  provideCompletionItems(document, position, _token, context) {
    if (context.triggerCharacter != "@") {
      return [];
    }
    const file2 = this.client.toPath(document.uri);
    if (!file2) {
      return [];
    }
    const doc = import_coc6.workspace.getDocument(document.uri);
    const line = doc.getline(position.line);
    const prefix = line.slice(0, position.character);
    const match = prefix.match(/^\s*\/\/+\s?(@[a-zA-Z\-]*)?$/);
    if (match) {
      const directives = this.client.apiVersion.gte(api_default.v390) ? tsDirectives390 : tsDirectives;
      let items = directives.map((directive) => {
        const item = import_vscode_languageserver_protocol9.CompletionItem.create(directive.value);
        item.kind = import_vscode_languageserver_protocol9.CompletionItemKind.Snippet;
        item.detail = directive.description;
        item.textEdit = {
          range: import_vscode_languageserver_protocol9.Range.create(position.line, Math.max(0, position.character - (match[1] ? match[1].length : 0)), position.line, position.character),
          newText: directive.value
        };
        return item;
      });
      let res = {
        isIncomplete: false,
        items
      };
      res.startcol = doc.fixStartcol(position, ["@"]);
      return res;
    }
    return [];
  }
};
var directiveCommentCompletions_default = DirectiveCommentCompletionProvider;

// src/server/features/documentHighlight.ts
var import_vscode_languageserver_protocol10 = __toModule(require_main3());
var TypeScriptDocumentHighlightProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideDocumentHighlights(resource, position, token) {
    const file2 = this.client.toPath(resource.uri);
    if (!file2)
      return [];
    const args = {
      ...Position.toFileLocationRequestArgs(file2, position),
      filesToSearch: [file2]
    };
    try {
      const response = await this.client.execute("documentHighlights", args, token);
      if (response.type !== "response" || !response.body) {
        return [];
      }
      return flatten(response.body.filter((highlight) => highlight.file === file2).map(convertDocumentHighlight));
    } catch (_e) {
      return [];
    }
  }
};
var documentHighlight_default = TypeScriptDocumentHighlightProvider;
function convertDocumentHighlight(highlight) {
  return highlight.highlightSpans.map((span) => {
    return {
      range: Range.fromTextSpan(span),
      kind: span.kind === "writtenReference" ? import_vscode_languageserver_protocol10.DocumentHighlightKind.Write : import_vscode_languageserver_protocol10.DocumentHighlightKind.Read
    };
  });
}

// src/server/features/documentSymbol.ts
var import_vscode_languageserver_protocol11 = __toModule(require_main3());
var getSymbolKind2 = (kind) => {
  switch (kind) {
    case Kind.module:
      return import_vscode_languageserver_protocol11.SymbolKind.Module;
    case Kind.class:
      return import_vscode_languageserver_protocol11.SymbolKind.Class;
    case Kind.enum:
      return import_vscode_languageserver_protocol11.SymbolKind.Enum;
    case Kind.interface:
      return import_vscode_languageserver_protocol11.SymbolKind.Interface;
    case Kind.method:
      return import_vscode_languageserver_protocol11.SymbolKind.Method;
    case Kind.memberVariable:
      return import_vscode_languageserver_protocol11.SymbolKind.Property;
    case Kind.memberGetAccessor:
      return import_vscode_languageserver_protocol11.SymbolKind.Property;
    case Kind.memberSetAccessor:
      return import_vscode_languageserver_protocol11.SymbolKind.Property;
    case Kind.variable:
      return import_vscode_languageserver_protocol11.SymbolKind.Variable;
    case Kind.const:
      return import_vscode_languageserver_protocol11.SymbolKind.Variable;
    case Kind.localVariable:
      return import_vscode_languageserver_protocol11.SymbolKind.Variable;
    case Kind.variable:
      return import_vscode_languageserver_protocol11.SymbolKind.Variable;
    case Kind.constructSignature:
    case Kind.constructorImplementation:
    case Kind.function:
    case Kind.localFunction:
      return import_vscode_languageserver_protocol11.SymbolKind.Function;
  }
  return import_vscode_languageserver_protocol11.SymbolKind.Variable;
};
var TypeScriptDocumentSymbolProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideDocumentSymbols(resource, token) {
    const filepath = this.client.toPath(resource.uri);
    if (!filepath)
      return [];
    const args = {
      file: filepath
    };
    try {
      const response = await this.client.execute("navtree", args, token);
      if (response.type == "response" && response.body) {
        const tree = response.body;
        if (tree.childItems) {
          const result = new Array();
          tree.childItems.forEach((item) => TypeScriptDocumentSymbolProvider.convertNavTree(result, item));
          return result;
        }
      }
      return [];
    } catch (e) {
      return [];
    }
  }
  static convertNavTree(bucket, item) {
    let shouldInclude = TypeScriptDocumentSymbolProvider.shouldInclueEntry(item);
    const children = new Set(item.childItems || []);
    for (const span of item.spans) {
      const range = Range.fromTextSpan(span);
      const symbolInfo = import_vscode_languageserver_protocol11.DocumentSymbol.create(item.text, "", getSymbolKind2(item.kind), range, range);
      symbolInfo.children = children.size > 0 ? [] : null;
      for (const child of children) {
        if (child.spans.some((span2) => !!containsRange(range, Range.fromTextSpan(span2)))) {
          const includedChild = TypeScriptDocumentSymbolProvider.convertNavTree(symbolInfo.children, child);
          shouldInclude = shouldInclude || includedChild;
          children.delete(child);
        }
      }
      if (shouldInclude) {
        bucket.push(symbolInfo);
      }
    }
    return shouldInclude;
  }
  static shouldInclueEntry(item) {
    if (item.kind === Kind.alias) {
      return false;
    }
    return !!(item.text && item.text !== "<function>" && item.text !== "<class>");
  }
};
var documentSymbol_default = TypeScriptDocumentSymbolProvider;
function containsRange(range, otherRange) {
  if (otherRange.start.line < range.start.line || otherRange.end.line < range.start.line) {
    return false;
  }
  if (otherRange.start.line > range.end.line || otherRange.end.line > range.end.line) {
    return false;
  }
  if (otherRange.start.line === range.start.line && otherRange.start.character < range.start.character) {
    return false;
  }
  if (otherRange.end.line === range.end.line && otherRange.end.character > range.end.character) {
    return false;
  }
  return true;
}

// src/server/features/folding.ts
var import_coc7 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_types = __toModule(require_main2());
var TypeScriptFoldingProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideFoldingRanges(document, _context, token) {
    const file2 = this.client.toPath(document.uri);
    if (!file2) {
      return;
    }
    const args = {file: file2};
    const res = await this.client.execute("getOutliningSpans", args, token);
    if (res.type != "response") {
      return;
    }
    const {body} = res;
    if (!body) {
      return;
    }
    return body.map((span) => this.convertOutliningSpan(span, document)).filter((foldingRange) => !!foldingRange);
  }
  convertOutliningSpan(span, document) {
    const range = Range.fromTextSpan(span.textSpan);
    const kind = TypeScriptFoldingProvider.getFoldingRangeKind(span);
    if (span.kind === "comment") {
      let doc = import_coc7.workspace.getDocument(document.uri);
      const line = doc.getline(range.start.line);
      if (line.match(/\/\/\s*#endregion/gi)) {
        return void 0;
      }
    }
    let {start, end} = range;
    return import_vscode_languageserver_types.FoldingRange.create(start.line, end.line, start.character, end.character, kind);
  }
  static getFoldingRangeKind(span) {
    switch (span.kind) {
      case "comment":
      case "region":
      case "imports":
      case "code":
        return span.kind;
      default:
        return void 0;
    }
  }
};
var folding_default = TypeScriptFoldingProvider;

// src/server/features/formatting.ts
var import_coc8 = __toModule(require("coc.nvim"));
var TypeScriptFormattingProvider = class {
  constructor(client, formattingOptionsManager) {
    this.client = client;
    this.formattingOptionsManager = formattingOptionsManager;
  }
  enabled(document) {
    return this.formattingOptionsManager.formatEnabled(document);
  }
  async doFormat(document, options, args, token) {
    if (!this.enabled(document))
      return [];
    await this.formattingOptionsManager.ensureConfigurationOptions(document, options.insertSpaces, options.tabSize, token);
    try {
      const response = await this.client.execute("format", args, token);
      if (response.type == "response" && response.body) {
        let edits = response.body.map(TextEdit.fromCodeEdit);
        return edits;
      }
    } catch {
    }
    return [];
  }
  async provideDocumentRangeFormattingEdits(document, range, options, token) {
    if (!this.enabled(document))
      return [];
    const filepath = this.client.toPath(document.uri);
    if (!filepath)
      return [];
    const args = {
      file: filepath,
      line: range.start.line + 1,
      offset: range.start.character + 1,
      endLine: range.end.line + 1,
      endOffset: range.end.character + 1
    };
    return this.doFormat(document, options, args, token);
  }
  async provideDocumentFormattingEdits(document, options, token) {
    if (!this.enabled(document))
      return [];
    const filepath = this.client.toPath(document.uri);
    if (!filepath)
      return [];
    const args = {
      file: filepath,
      line: 1,
      offset: 1,
      endLine: document.lineCount + 1,
      endOffset: 1
    };
    return this.doFormat(document, options, args, token);
  }
  async provideOnTypeFormattingEdits(document, position, ch, options, token) {
    if (!this.enabled(document))
      return [];
    if (!this.client.configuration.formatOnType)
      return [];
    const file2 = this.client.toPath(document.uri);
    if (!file2)
      return [];
    await this.formattingOptionsManager.ensureConfigurationOptions(document, options.insertSpaces, options.tabSize, token);
    const doc = import_coc8.workspace.getDocument(document.uri);
    const args = {
      ...Position.toFileLocationRequestArgs(file2, position),
      key: ch
    };
    try {
      const res = await this.client.execute("formatonkey", args, token);
      if (res.type != "response") {
        return [];
      }
      const {body} = res;
      const edits = body;
      const result = [];
      if (!edits) {
        return result;
      }
      for (const edit of edits) {
        const textEdit = TextEdit.fromCodeEdit(edit);
        const range = textEdit.range;
        if (range.start.character === 0 && range.start.line === range.end.line && textEdit.newText === "") {
          const lText = doc.getline(range.start.line);
          if (lText.trim().length > 0 || lText.length > range.end.character) {
            result.push(textEdit);
          }
        } else {
          result.push(textEdit);
        }
      }
      return result;
    } catch {
    }
    return [];
  }
};
var formatting_default = TypeScriptFormattingProvider;

// src/server/features/hover.ts
var TypeScriptHoverProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideHover(document, position, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath) {
      return void 0;
    }
    const args = Position.toFileLocationRequestArgs(filepath, position);
    try {
      const response = await this.client.interruptGetErr(() => this.client.execute("quickinfo", args, token));
      if (response && response.type == "response" && response.body) {
        const data = response.body;
        return {
          contents: TypeScriptHoverProvider.getContents(data),
          range: Range.fromTextSpan(data)
        };
      }
    } catch (e) {
    }
    return void 0;
  }
  static getContents(data) {
    const parts = [];
    if (data.displayString) {
      parts.push({language: "typescript", value: data.displayString});
    }
    const tags = tagsMarkdownPreview(data.tags);
    parts.push(data.documentation + (tags ? "\n\n" + tags : ""));
    return parts;
  }
};
var hover_default = TypeScriptHoverProvider;

// src/server/features/implementationsCodeLens.ts
var TypeScriptImplementationsCodeLensProvider = class extends TypeScriptBaseCodeLensProvider {
  async resolveCodeLens(codeLens, token) {
    let {uri} = codeLens.data;
    let filepath = this.client.toPath(uri);
    const args = Position.toFileLocationRequestArgs(filepath, codeLens.range.start);
    try {
      const response = await this.client.execute("implementation", args, token, {lowPriority: true});
      if (response && response.type == "response" && response.body) {
        const locations = response.body.map((reference) => {
          return {
            uri: this.client.toResource(reference.file),
            range: {
              start: Position.fromLocation(reference.start),
              end: {
                line: reference.start.line,
                character: 0
              }
            }
          };
        }).filter((location) => !(location.uri.toString() === uri && location.range.start.line === codeLens.range.start.line && location.range.start.character === codeLens.range.start.character));
        codeLens.command = this.getCommand(locations, codeLens);
        return codeLens;
      }
    } catch {
    }
    codeLens.command = {
      title: "0 implementations",
      command: ""
    };
    return codeLens;
  }
  getCommand(locations, codeLens) {
    let {uri} = codeLens.data;
    return {
      title: this.getTitle(locations),
      command: locations.length ? "editor.action.showReferences" : "",
      arguments: [uri, codeLens.range.start, locations]
    };
  }
  getTitle(locations) {
    return locations.length === 1 ? "1 implementation" : `${locations.length} implementations`;
  }
  extractSymbol(document, item, _parent) {
    switch (item.kind) {
      case Kind.interface:
        return super.getSymbolRange(document, item);
      case Kind.class:
      case Kind.method:
      case Kind.memberVariable:
      case Kind.memberGetAccessor:
      case Kind.memberSetAccessor:
        if (item.kindModifiers.match(/\babstract\b/g)) {
          return super.getSymbolRange(document, item);
        }
        break;
    }
    return null;
  }
};
var implementationsCodeLens_default = TypeScriptImplementationsCodeLensProvider;

// src/server/features/importFix.ts
var import_coc9 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol12 = __toModule(require_main3());

// src/server/utils/helper.ts
var nodeModules = [
  "assert",
  "cluster",
  "crypto",
  "dns",
  "domain",
  "events",
  "fs",
  "http",
  "http2",
  "https",
  "inspector",
  "net",
  "os",
  "path",
  "punycode",
  "querystring",
  "readline",
  "repl",
  "stream",
  "string_decoder",
  "tls",
  "tty",
  "url",
  "util",
  "v8",
  "vm",
  "zlib",
  "perf_hooks"
];

// src/server/features/importFix.ts
var ImportFixProvider = class {
  constructor(bufferSyncSupport) {
    this.bufferSyncSupport = bufferSyncSupport;
  }
  async provideCodeActions(document, _range, context, _token) {
    if (this.bufferSyncSupport.hasPendingDiagnostics(document.uri)) {
      return [];
    }
    let diagnostics = context.diagnostics.filter((d) => d.code == 2304);
    if (!diagnostics.length)
      return [];
    let edits = [];
    let names = [];
    let doc = import_coc9.workspace.getDocument(document.uri);
    let command;
    for (const diagnostic of diagnostics) {
      let {range} = diagnostic;
      let line = doc.getline(range.start.line);
      let name = line.slice(range.start.character, range.end.character);
      if (names.indexOf(name) !== -1)
        continue;
      if (nodeModules.indexOf(name) !== -1) {
        names.push(name);
        edits.push({
          range: import_vscode_languageserver_protocol12.Range.create(0, 0, 0, 0),
          newText: `import ${name} from '${name}'
`
        });
        command = "tsserver.organizeImports";
      }
    }
    let edit = {
      changes: {
        [document.uri]: edits
      }
    };
    let cmd = null;
    if (command)
      cmd = {
        title: `fix import`,
        command: "tsserver.organizeImports"
      };
    return [{
      title: `Add import ${names.join(", ")}`,
      edit,
      command: cmd
    }];
  }
};
var importFix_default = ImportFixProvider;

// src/server/features/moduleInstall.ts
var import_coc11 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol13 = __toModule(require_main3());

// src/server/utils/modules.ts
var import_child_process = __toModule(require("child_process"));
var import_coc10 = __toModule(require("coc.nvim"));
var import_fs = __toModule(require("fs"));
var import_path2 = __toModule(require("path"));
function runCommand(cmd, cwd, timeout) {
  return new Promise((resolve, reject) => {
    let timer;
    if (timeout) {
      timer = setTimeout(() => {
        reject(new Error(`timeout after ${timeout}s`));
      }, timeout * 1e3);
    }
    import_child_process.exec(cmd, {cwd}, (err, stdout) => {
      if (timer)
        clearTimeout(timer);
      if (err) {
        reject(new Error(`exited with ${err.code}`));
        return;
      }
      resolve(stdout);
    });
  });
}
async function getManager() {
  let res = await import_coc10.workspace.findUp(["yarn.lock", "package-lock.json"]);
  if (!res)
    return "yarn";
  return res.endsWith("yarn.lock") ? "yarn" : "npm";
}
async function moduleExists(name) {
  try {
    let content = await runCommand(`npm info ${name} --json`, process.cwd());
    if (!content)
      return false;
    let obj = JSON.parse(content);
    if (obj.error != null)
      return false;
    return true;
  } catch (e) {
    return false;
  }
  return false;
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => {
      return array.indexOf(element) === position;
    });
  }
  const seen = Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
async function installModules(uri, names) {
  names = distinct(names);
  let workspaceFolder = import_coc10.workspace.getWorkspaceFolder(uri);
  let root = workspaceFolder ? import_coc10.Uri.parse(workspaceFolder.uri).fsPath : void 0;
  if (!root || !import_fs.default.existsSync(import_path2.default.join(root, "package.json"))) {
    import_coc10.window.showMessage(`package.json not found from workspaceFolder: ${root}`, "error");
    return;
  }
  let arr = names.concat(names.map((s) => `@types/${s}`));
  let statusItem = import_coc10.window.createStatusBarItem(99, {progress: true});
  statusItem.text = `Checking module ${arr.join(" ")}`;
  statusItem.show();
  let exists = await Promise.all(arr.map((name) => {
    return moduleExists(name).then((exists2) => {
      return exists2 ? name : null;
    });
  }));
  let manager = await getManager();
  exists = exists.filter((s) => s != null);
  if (!exists.length)
    return;
  let devs = exists.filter((s) => s.startsWith("@types"));
  let deps = exists.filter((s) => devs.indexOf(s) == -1);
  statusItem.text = `Installing ${exists.join(" ")}`;
  try {
    let cmd = manager == "npm" ? `npm i ${deps.join(" ")}` : `yarn add ${deps.join(" ")}`;
    await runCommand(cmd, root);
    cmd = manager == "npm" ? `npm i ${deps.join(" ")} --save-dev` : `yarn add ${deps.join(" ")} --save-dev`;
    await runCommand(cmd, root);
  } catch (e) {
    statusItem.dispose();
    import_coc10.window.showMessage(`Install error ${e.message}`, "error");
    return;
  }
  statusItem.dispose();
  import_coc10.window.showMessage(`Installed: ${exists.join(" ")}`, "more");
}

// src/server/features/moduleInstall.ts
var InstallModuleProvider = class {
  constructor(client) {
    this.client = client;
    import_coc11.commands.registerCommand("_tsserver.installModule", async (uri, name) => {
      await installModules(uri, [name]);
    });
  }
  async provideCodeActions(document, _range, context, _token) {
    const uri = import_coc11.Uri.parse(document.uri);
    if (uri.scheme != "file")
      return null;
    let {diagnostics} = context;
    let diags = diagnostics.filter((s) => s.code == 2307);
    let names = diags.map((o) => {
      let ms = o.message.match(/module\s'(.+)'/);
      return ms ? ms[1] : null;
    });
    names = names.filter((s) => s != null);
    if (!names.length)
      return null;
    let actions = [];
    for (let name of names) {
      let title = `install ${name}`;
      let command = {
        title: `install ${name}`,
        command: "_tsserver.installModule",
        arguments: [document.uri, name]
      };
      let codeAction = import_vscode_languageserver_protocol13.CodeAction.create(title, command, import_vscode_languageserver_protocol13.CodeActionKind.QuickFix);
      actions.push(codeAction);
    }
    return actions;
  }
};
var moduleInstall_default = InstallModuleProvider;

// src/server/features/quickfix.ts
var import_coc13 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol14 = __toModule(require_main3());

// src/server/commands.ts
var import_coc12 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_types2 = __toModule(require_main2());
var ReloadProjectsCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.reloadProjects";
  }
  async execute() {
    let client = await this.service.getClientHost();
    client.reloadProjects();
    import_coc12.window.showMessage("projects reloaded");
  }
};
var OpenTsServerLogCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.openTsServerLog";
  }
  async execute() {
    let client = await this.service.getClientHost();
    client.serviceClient.openTsServerLogFile();
  }
};
var TypeScriptGoToProjectConfigCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.goToProjectConfig";
  }
  async execute() {
    let client = await this.service.getClientHost();
    let doc = await import_coc12.workspace.document;
    let {languageId} = doc.textDocument;
    if (client.serviceClient.modeIds.indexOf(languageId) == -1) {
      throw new Error(`Could not determine TypeScript or JavaScript project. Unsupported file type: ${languageId}`);
      return;
    }
    await goToProjectConfig(client, doc.uri);
  }
};
async function goToProjectConfig(clientHost, uri) {
  const client = clientHost.serviceClient;
  const file2 = client.toPath(uri);
  let res;
  try {
    res = await client.execute("projectInfo", {file: file2, needFileNameList: false}, import_coc12.CancellationToken.None);
  } catch {
  }
  if (!res || !res.body) {
    import_coc12.window.showMessage("Could not determine TypeScript or JavaScript project.", "warning");
    return;
  }
  const {configFileName} = res.body;
  if (configFileName && !isImplicitProjectConfigFile(configFileName)) {
    await import_coc12.workspace.openResource(import_coc12.Uri.file(configFileName).toString());
    return;
  }
  import_coc12.window.showMessage("Config file not found", "warning");
}
function isImplicitProjectConfigFile(configFileName) {
  return configFileName.indexOf("/dev/null/") === 0;
}
var autoFixableDiagnosticCodes = new Set([
  2420,
  2552,
  2304
]);
var AutoFixCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.executeAutofix";
  }
  async execute() {
    if (this.service.state != import_coc12.ServiceStat.Running) {
      throw new Error("service not running");
      return;
    }
    let client = await this.service.getClientHost();
    let document = await import_coc12.workspace.document;
    let handles = await client.handles(document.textDocument);
    if (!handles) {
      throw new Error(`Document ${document.uri} is not handled by tsserver.`);
      return;
    }
    let file2 = client.serviceClient.toPath(document.uri);
    let diagnostics = import_coc12.diagnosticManager.getDiagnostics(document.uri).slice();
    let missingDiagnostics = diagnostics.filter((o) => o.code == 2307);
    if (missingDiagnostics.length) {
      let names2 = missingDiagnostics.map((o) => {
        let ms = o.message.match(/module\s'(.+)'\./);
        return ms ? ms[1] : null;
      });
      names2 = names2.filter((s) => s != null);
      if (names2.length) {
        installModules(document.uri, names2).catch((e) => {
          console.error(e.message);
        });
      }
    }
    diagnostics = diagnostics.filter((x) => autoFixableDiagnosticCodes.has(x.code));
    if (diagnostics.length == 0)
      return;
    diagnostics = diagnostics.reduce((arr, curr) => {
      if (curr.code == 2304 && arr.findIndex((o) => o.message == curr.message) != -1)
        return arr;
      arr.push(curr);
      return arr;
    }, []);
    let edits = [];
    let command;
    let names = [];
    for (let diagnostic of diagnostics) {
      const args = {
        ...Range.toFileRangeRequestArgs(file2, diagnostic.range),
        errorCodes: [+diagnostic.code]
      };
      const response = await client.serviceClient.execute("getCodeFixes", args, import_coc12.CancellationToken.None);
      if (response.type !== "response" || !response.body || response.body.length < 1) {
        if (diagnostic.code == 2304) {
          let {range} = diagnostic;
          let line = document.getline(range.start.line);
          let name = line.slice(range.start.character, range.end.character);
          if (nodeModules.indexOf(name) !== -1 && names.indexOf(name) == -1) {
            names.push(name);
            edits.push({
              range: import_vscode_languageserver_types2.Range.create(0, 0, 0, 0),
              newText: `import ${name} from '${name}'
`
            });
            command = "tsserver.organizeImports";
          }
        }
        continue;
      }
      const fix = response.body[0];
      for (let change of fix.changes) {
        if (change.fileName != file2)
          continue;
        for (let ch of change.textChanges) {
          edits.push({
            range: Range.fromTextSpan(ch),
            newText: ch.newText
          });
        }
      }
    }
    if (edits.length)
      await document.applyEdits(edits);
    if (command)
      import_coc12.commands.executeCommand(command);
  }
};
var ConfigurePluginCommand = class {
  constructor(pluginManager) {
    this.pluginManager = pluginManager;
    this.id = "_typescript.configurePlugin";
  }
  execute(pluginId, configuration) {
    this.pluginManager.setConfiguration(pluginId, configuration);
  }
};
function registCommand(cmd) {
  let {id, execute} = cmd;
  return import_coc12.commands.registerCommand(id, execute, cmd);
}

// src/server/features/quickfix.ts
var ApplyCodeActionCommand2 = class {
  constructor(client, formattingConfigurationManager) {
    this.client = client;
    this.formattingConfigurationManager = formattingConfigurationManager;
    this.id = ApplyCodeActionCommand2.ID;
  }
  async execute(action) {
    return applyCodeActionCommands(this.client, action);
  }
};
var ApplyCodeActionCommand = ApplyCodeActionCommand2;
ApplyCodeActionCommand.ID = "_typescript.applyCodeActionCommand";
var ApplyFixAllCodeAction2 = class {
  constructor(client, formattingConfigurationManager) {
    this.client = client;
    this.formattingConfigurationManager = formattingConfigurationManager;
    this.id = ApplyFixAllCodeAction2.ID;
  }
  async execute(document, file2, tsAction) {
    if (!tsAction.fixId) {
      return;
    }
    await this.formattingConfigurationManager.ensureConfigurationForDocument(document, import_vscode_languageserver_protocol14.CancellationToken.None);
    const args = {
      scope: {
        type: "file",
        args: {file: file2}
      },
      fixId: tsAction.fixId
    };
    try {
      const res = await this.client.execute("getCombinedCodeFix", args, import_vscode_languageserver_protocol14.CancellationToken.None);
      if (res.type != "response") {
        return;
      }
      let {body} = res;
      const edit = WorkspaceEdit.fromFileCodeEdits(this.client, body.changes);
      await import_coc13.workspace.applyEdit(edit);
      const token = import_vscode_languageserver_protocol14.CancellationToken.None;
      const {commands: commands7} = body;
      if (commands7 && commands7.length) {
        for (const command of commands7) {
          await this.client.execute("applyCodeActionCommand", {command}, token);
        }
      }
    } catch {
    }
  }
};
var ApplyFixAllCodeAction = ApplyFixAllCodeAction2;
ApplyFixAllCodeAction.ID = "_typescript.applyFixAllCodeAction";
var DiagnosticsSet = class {
  constructor(_values) {
    this._values = _values;
  }
  static from(diagnostics) {
    const values = new Map();
    for (const diagnostic of diagnostics) {
      values.set(DiagnosticsSet.key(diagnostic), diagnostic);
    }
    return new DiagnosticsSet(values);
  }
  static key(diagnostic) {
    const {start, end} = diagnostic.range;
    return `${diagnostic.code}-${start.line},${start.character}-${end.line},${end.character}`;
  }
  get values() {
    return this._values.values();
  }
};
var SupportedCodeActionProvider = class {
  constructor(client) {
    this.client = client;
  }
  async getFixableDiagnosticsForContext(context) {
    const supportedActions = await this.supportedCodeActions;
    const fixableDiagnostics = DiagnosticsSet.from(context.diagnostics.filter((diagnostic) => supportedActions.has(+diagnostic.code)));
    return Array.from(fixableDiagnostics.values);
  }
  get supportedCodeActions() {
    if (!this._supportedCodeActions) {
      return new Promise((resolve, reject) => {
        this.client.execute("getSupportedCodeFixes", null, import_vscode_languageserver_protocol14.CancellationToken.None).then((res) => {
          if (res.type !== "response") {
            resolve(new Set());
            return;
          }
          let codes = res.body.map((code) => +code).filter((code) => !isNaN(code));
          resolve(new Set(codes));
        }, reject);
      });
    }
    return Promise.resolve(this._supportedCodeActions);
  }
};
var TypeScriptQuickFixProvider = class {
  constructor(client, formattingConfigurationManager) {
    this.client = client;
    this.formattingConfigurationManager = formattingConfigurationManager;
    registCommand(new ApplyCodeActionCommand(client, formattingConfigurationManager));
    registCommand(new ApplyFixAllCodeAction(client, formattingConfigurationManager));
    this.supportedCodeActionProvider = new SupportedCodeActionProvider(client);
  }
  async provideCodeActions(document, _range, context, token) {
    const file2 = this.client.toPath(document.uri);
    if (!file2) {
      return [];
    }
    await this.formattingConfigurationManager.ensureConfigurationForDocument(document, token);
    const fixableDiagnostics = await this.supportedCodeActionProvider.getFixableDiagnosticsForContext(context);
    if (!fixableDiagnostics.length) {
      return [];
    }
    if (this.client.bufferSyncSupport.hasPendingDiagnostics(document.uri)) {
      return [];
    }
    const results = [];
    for (const diagnostic of fixableDiagnostics) {
      results.push(...await this.getFixesForDiagnostic(document, file2, diagnostic, token));
    }
    return results;
  }
  async getFixesForDiagnostic(document, file2, diagnostic, token) {
    const args = {
      ...Range.toFileRangeRequestArgs(file2, diagnostic.range),
      errorCodes: [+diagnostic.code]
    };
    const codeFixesResponse = await this.client.execute("getCodeFixes", args, token);
    if (codeFixesResponse.type != "response") {
      return [];
    }
    if (codeFixesResponse.body) {
      const results = [];
      for (const tsCodeFix of codeFixesResponse.body) {
        results.push(...await this.getAllFixesForTsCodeAction(document, file2, diagnostic, tsCodeFix));
      }
      return results;
    }
    return [];
  }
  async getAllFixesForTsCodeAction(document, file2, diagnostic, tsAction) {
    const singleFix = this.getSingleFixForTsCodeAction(diagnostic, tsAction);
    const fixAll = await this.getFixAllForTsCodeAction(document, file2, diagnostic, tsAction);
    return fixAll ? [singleFix, fixAll] : [singleFix];
  }
  getSingleFixForTsCodeAction(diagnostic, tsAction) {
    const codeAction = {
      title: tsAction.description,
      kind: import_vscode_languageserver_protocol14.CodeActionKind.QuickFix
    };
    codeAction.edit = getEditForCodeAction(this.client, tsAction);
    codeAction.diagnostics = [diagnostic];
    codeAction.isPreferred = true;
    if (tsAction.commands) {
      codeAction.command = {
        command: ApplyCodeActionCommand.ID,
        arguments: [tsAction],
        title: tsAction.description
      };
    }
    return codeAction;
  }
  async getFixAllForTsCodeAction(document, file2, diagnostic, tsAction) {
    if (!tsAction.fixId || !this.client.apiVersion.gte(api_default.v270)) {
      return void 0;
    }
    if (!this.client.diagnosticsManager.getDiagnostics(document.uri).some((x) => x.code === diagnostic.code && x !== diagnostic)) {
      return;
    }
    const action = {
      title: tsAction.fixAllDescription || "Fix all in file",
      kind: import_vscode_languageserver_protocol14.CodeActionKind.QuickFix
    };
    action.diagnostics = [diagnostic];
    action.command = {
      command: ApplyFixAllCodeAction.ID,
      arguments: [document, file2, tsAction],
      title: ""
    };
    return action;
  }
};
var quickfix_default = TypeScriptQuickFixProvider;

// src/server/features/refactor.ts
var import_coc14 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol15 = __toModule(require_main3());
var ApplyRefactoringCommand2 = class {
  constructor(client) {
    this.client = client;
    this.id = ApplyRefactoringCommand2.ID;
  }
  async execute(document, file2, refactor, action, range) {
    const args = {
      ...Range.toFileRangeRequestArgs(file2, range),
      refactor,
      action
    };
    const response = await this.client.execute("getEditsForRefactor", args, import_vscode_languageserver_protocol15.CancellationToken.None);
    const body = response && response.body;
    if (!body || !body.edits.length) {
      return false;
    }
    const workspaceEdit = await this.toWorkspaceEdit(body);
    if (!await import_coc14.workspace.applyEdit(workspaceEdit)) {
      return false;
    }
    const renameLocation = body.renameLocation;
    if (renameLocation) {
      import_coc14.commands.executeCommand("editor.action.rename", document.uri, Position.fromLocation(renameLocation));
    }
    return true;
  }
  async toWorkspaceEdit(body) {
    for (const edit of body.edits) {
      await import_coc14.workspace.createFile(edit.fileName, {ignoreIfExists: true});
    }
    let workspaceEdit = WorkspaceEdit.fromFileCodeEdits(this.client, body.edits);
    return workspaceEdit;
  }
};
var ApplyRefactoringCommand = ApplyRefactoringCommand2;
ApplyRefactoringCommand.ID = "_typescript.applyRefactoring";
var SelectRefactorCommand2 = class {
  constructor(doRefactoring) {
    this.doRefactoring = doRefactoring;
    this.id = SelectRefactorCommand2.ID;
  }
  async execute(document, file2, info, range) {
    let {actions} = info;
    const idx = actions.length == 1 ? 0 : await import_coc14.window.showQuickpick(actions.map((action) => action.description || action.name));
    if (idx == -1)
      return false;
    let label = info.actions[idx].name;
    if (!label)
      return false;
    return this.doRefactoring.execute(document, file2, info.name, label, range);
  }
};
var SelectRefactorCommand = SelectRefactorCommand2;
SelectRefactorCommand.ID = "_typescript.selectRefactoring";
var TypeScriptRefactorProvider2 = class {
  constructor(client, formattingOptionsManager) {
    this.client = client;
    this.formattingOptionsManager = formattingOptionsManager;
    const doRefactoringCommand = new ApplyRefactoringCommand(this.client);
    registCommand(doRefactoringCommand);
    registCommand(new SelectRefactorCommand(doRefactoringCommand));
  }
  async provideCodeActions(document, range, context, token) {
    if (!this.shouldTrigger(context)) {
      return void 0;
    }
    const file2 = this.client.toPath(document.uri);
    if (!file2)
      return void 0;
    await this.formattingOptionsManager.ensureConfigurationForDocument(document, token);
    const args = Range.toFileRangeRequestArgs(file2, range);
    let response;
    try {
      response = await this.client.interruptGetErr(() => {
        return this.client.execute("getApplicableRefactors", args, token);
      });
      if (!response || !response.body) {
        return void 0;
      }
    } catch {
      return void 0;
    }
    return this.convertApplicableRefactors(response.body, document, file2, range, context.only && context.only.some((v) => v.includes(import_vscode_languageserver_protocol15.CodeActionKind.Refactor)));
  }
  convertApplicableRefactors(body, document, file2, rangeOrSelection, setPrefrred) {
    const actions = [];
    for (const info of body) {
      if (info.notApplicableReason)
        continue;
      if (!info.inlineable) {
        const codeAction = {
          title: info.description,
          kind: import_vscode_languageserver_protocol15.CodeActionKind.Refactor
        };
        codeAction.command = {
          title: info.description,
          command: SelectRefactorCommand.ID,
          arguments: [document, file2, info, rangeOrSelection]
        };
        actions.push(codeAction);
      } else {
        for (const action of info.actions) {
          let codeAction = this.refactorActionToCodeAction(action, document, file2, info, rangeOrSelection);
          if (setPrefrred) {
            codeAction.isPreferred = TypeScriptRefactorProvider2.isPreferred(action, info.actions);
          }
          actions.push(codeAction);
        }
      }
    }
    return actions;
  }
  refactorActionToCodeAction(action, document, file2, info, rangeOrSelection) {
    const codeAction = {
      title: action.description,
      kind: TypeScriptRefactorProvider2.getKind(action)
    };
    codeAction.command = {
      title: action.description,
      command: ApplyRefactoringCommand.ID,
      arguments: [document, file2, info.name, action.name, rangeOrSelection]
    };
    return codeAction;
  }
  shouldTrigger(context) {
    if (context.only && context.only.every((o) => !o.includes(import_vscode_languageserver_protocol15.CodeActionKind.Refactor))) {
      return false;
    }
    return true;
  }
  static getKind(refactor) {
    if (refactor.name.startsWith("function_")) {
      return TypeScriptRefactorProvider2.extractFunctionKind;
    } else if (refactor.name.startsWith("constant_")) {
      return TypeScriptRefactorProvider2.extractConstantKind;
    } else if (refactor.name.startsWith("Move")) {
      return TypeScriptRefactorProvider2.moveKind;
    }
    return import_vscode_languageserver_protocol15.CodeActionKind.Refactor;
  }
  static isPreferred(action, allActions) {
    let kind = TypeScriptRefactorProvider2.getKind(action);
    if (TypeScriptRefactorProvider2.extractConstantKind == kind) {
      const getScope = (name2) => {
        var _a;
        const scope2 = (_a = name2.match(/scope_(\d)/)) == null ? void 0 : _a[1];
        return scope2 ? +scope2 : void 0;
      };
      const scope = getScope(action.name);
      if (typeof scope !== "number") {
        return false;
      }
      return allActions.filter((otherAtion) => otherAtion !== action && otherAtion.name.startsWith("constant_")).every((otherAction) => {
        const otherScope = getScope(otherAction.name);
        return typeof otherScope === "number" ? scope < otherScope : true;
      });
    }
    let {name} = action;
    if (name.startsWith("Extract to type alias") || name.startsWith("Extract to interface")) {
      return true;
    }
    return false;
  }
};
var TypeScriptRefactorProvider = TypeScriptRefactorProvider2;
TypeScriptRefactorProvider.extractFunctionKind = import_vscode_languageserver_protocol15.CodeActionKind.RefactorExtract + ".function";
TypeScriptRefactorProvider.extractConstantKind = import_vscode_languageserver_protocol15.CodeActionKind.RefactorExtract + ".constant";
TypeScriptRefactorProvider.moveKind = import_vscode_languageserver_protocol15.CodeActionKind.Refactor + ".move";
TypeScriptRefactorProvider.metadata = {
  providedCodeActionKinds: [import_vscode_languageserver_protocol15.CodeActionKind.Refactor]
};
var refactor_default = TypeScriptRefactorProvider;

// src/server/features/references.ts
var TypeScriptReferences = class {
  constructor(client) {
    this.client = client;
  }
  async provideReferences(document, position, context, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath)
      return [];
    const args = Position.toFileLocationRequestArgs(filepath, position);
    try {
      const msg = await this.client.execute("references", args, token);
      if (!msg || msg.type != "response" || !msg.body) {
        return [];
      }
      const result = [];
      for (const ref of msg.body.refs) {
        if (!context.includeDeclaration && ref.isDefinition) {
          continue;
        }
        const url = this.client.toResource(ref.file);
        const location = Location2.fromTextSpan(url, ref);
        result.push(location);
      }
      return result;
    } catch {
      return [];
    }
  }
};
var references_default = TypeScriptReferences;

// src/server/features/referencesCodeLens.ts
var TypeScriptReferencesCodeLensProvider = class extends TypeScriptBaseCodeLensProvider {
  resolveCodeLens(codeLens, token) {
    let {uri} = codeLens.data;
    let filepath = this.client.toPath(uri);
    const args = Position.toFileLocationRequestArgs(filepath, codeLens.range.start);
    return this.client.execute("references", args, token, {
      lowPriority: true
    }).then((response) => {
      if (!response || response.type != "response" || !response.body) {
        throw codeLens;
      }
      const locations = response.body.refs.map((reference) => Location2.fromTextSpan(this.client.toResource(reference.file), reference)).filter((location) => !(location.uri.toString() === uri && location.range.start.line === codeLens.range.start.line && location.range.start.character === codeLens.range.start.character));
      codeLens.command = {
        title: locations.length === 1 ? "1 reference" : `${locations.length} references`,
        command: locations.length ? "editor.action.showReferences" : "",
        arguments: [uri, codeLens.range.start, locations]
      };
      return codeLens;
    }).catch(() => {
      codeLens.command = {
        title: "0 references",
        command: ""
      };
      return codeLens;
    });
  }
  extractSymbol(document, item, parent) {
    if (parent && parent.kind === Kind.enum) {
      return super.getSymbolRange(document, item);
    }
    switch (item.kind) {
      case Kind.const:
      case Kind.let:
      case Kind.variable:
      case Kind.function:
        if (!item.kindModifiers.match(/\bexport\b/)) {
          break;
        }
      case Kind.class:
        if (item.text === "<class>") {
          break;
        }
      case Kind.method:
      case Kind.memberVariable:
      case Kind.memberGetAccessor:
      case Kind.memberSetAccessor:
      case Kind.constructorImplementation:
      case Kind.interface:
      case Kind.type:
      case Kind.enum:
        return super.getSymbolRange(document, item);
    }
    return null;
  }
};
var referencesCodeLens_default = TypeScriptReferencesCodeLensProvider;

// src/server/features/rename.ts
var import_coc15 = __toModule(require("coc.nvim"));
var import_path3 = __toModule(require("path"));
var TypeScriptRenameProvider = class {
  constructor(client, fileConfigurationManager) {
    this.client = client;
    this.fileConfigurationManager = fileConfigurationManager;
  }
  async prepareRename(document, position, token) {
    const response = await this.execRename(document, position, token);
    if (!response || response.type !== "response" || !response.body) {
      return null;
    }
    const renameInfo = response.body.info;
    if (!renameInfo.canRename) {
      return Promise.reject(new Error("Invalid location for rename."));
    }
    if (this.client.apiVersion.gte(api_default.v310)) {
      const triggerSpan = renameInfo.triggerSpan;
      if (triggerSpan) {
        const range = Range.fromTextSpan(triggerSpan);
        return range;
      }
    }
    return null;
  }
  async provideRenameEdits(document, position, newName, token) {
    const response = await this.execRename(document, position, token);
    if (!response || response.type !== "response" || !response.body) {
      return null;
    }
    const renameInfo = response.body.info;
    if (!renameInfo.canRename) {
      return Promise.reject(new Error("Invalid location for rename."));
    }
    if (this.client.apiVersion.gte(api_default.v310)) {
      if (renameInfo.fileToRename) {
        const edits = await this.renameFile(renameInfo.fileToRename, newName, token);
        if (edits) {
          return edits;
        } else {
          return Promise.reject(new Error("An error occurred while renaming file"));
        }
      }
    }
    return this.toWorkspaceEdit(response.body.locs, newName);
  }
  async execRename(document, position, token) {
    const file2 = this.client.toPath(document.uri);
    if (!file2)
      return void 0;
    const args = {
      ...Position.toFileLocationRequestArgs(file2, position),
      findInStrings: false,
      findInComments: false
    };
    await this.fileConfigurationManager.ensureConfigurationForDocument(document, token);
    return this.client.interruptGetErr(() => {
      return this.client.execute("rename", args, token);
    });
  }
  toWorkspaceEdit(locations, newName) {
    let changes = {};
    for (const spanGroup of locations) {
      const uri = this.client.toResource(spanGroup.file);
      if (uri) {
        changes[uri] = [];
        for (const textSpan of spanGroup.locs) {
          changes[uri].push({
            range: Range.fromTextSpan(textSpan),
            newText: (textSpan.prefixText || "") + newName + (textSpan.suffixText || "")
          });
        }
      }
    }
    return {changes};
  }
  async renameFile(fileToRename, newName, token) {
    if (!import_path3.default.extname(newName)) {
      newName += import_path3.default.extname(fileToRename);
    }
    const dirname = import_path3.default.dirname(fileToRename);
    const newFilePath = import_path3.default.join(dirname, newName);
    const args = {
      file: fileToRename,
      oldFilePath: fileToRename,
      newFilePath
    };
    const response = await this.client.execute("getEditsForFileRename", args, token);
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    const edits = WorkspaceEdit.fromFileCodeEdits(this.client, response.body);
    edits.documentChanges = edits.documentChanges || [];
    edits.documentChanges.push({
      kind: "rename",
      oldUri: import_coc15.Uri.file(fileToRename).toString(),
      newUri: import_coc15.Uri.file(newFilePath).toString(),
      options: {
        overwrite: false,
        ignoreIfExists: true
      }
    });
    return edits;
  }
};
var rename_default = TypeScriptRenameProvider;

// src/server/features/signatureHelp.ts
var TypeScriptSignatureHelpProvider = class {
  constructor(client) {
    this.client = client;
  }
  async provideSignatureHelp(document, position, token) {
    const filepath = this.client.toPath(document.uri);
    if (!filepath) {
      return void 0;
    }
    const args = Position.toFileLocationRequestArgs(filepath, position);
    let response;
    try {
      response = await this.client.interruptGetErr(() => this.client.execute("signatureHelp", args, token));
    } catch (e) {
      return void 0;
    }
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    let info = response.body;
    const result = {
      activeSignature: info.selectedItemIndex,
      activeParameter: this.getActiveParmeter(info),
      signatures: info.items.map((signature) => {
        return this.convertSignature(signature);
      })
    };
    return result;
  }
  getActiveParmeter(info) {
    const activeSignature = info.items[info.selectedItemIndex];
    if (activeSignature && activeSignature.isVariadic) {
      return Math.min(info.argumentIndex, activeSignature.parameters.length - 1);
    }
    return info.argumentIndex;
  }
  convertSignature(item) {
    var _a;
    let parameters = item.parameters.map((p) => {
      return {
        label: plain(p.displayParts),
        documentation: markdownDocumentation(p.documentation, [])
      };
    });
    let label = plain(item.prefixDisplayParts);
    label += parameters.map((parameter) => parameter.label).join(plain(item.separatorDisplayParts));
    label += plain(item.suffixDisplayParts);
    return {
      label,
      documentation: markdownDocumentation(item.documentation, (_a = item.tags) == null ? void 0 : _a.filter((x) => x.name !== "param")),
      parameters
    };
  }
};
TypeScriptSignatureHelpProvider.triggerCharacters = ["(", ",", "<"];
var signatureHelp_default = TypeScriptSignatureHelpProvider;

// src/server/features/smartSelect.ts
var SmartSelection = class {
  constructor(client) {
    this.client = client;
  }
  async provideSelectionRanges(document, positions, token) {
    const file2 = this.client.toPath(document.uri);
    if (!file2) {
      return void 0;
    }
    const args = {
      file: file2,
      locations: positions.map(Position.toLocation)
    };
    const response = await this.client.execute("selectionRange", args, token);
    if (response.type !== "response" || !response.body) {
      return void 0;
    }
    return response.body.map(SmartSelection.convertSelectionRange);
  }
  static convertSelectionRange(selectionRange) {
    return {
      range: Range.fromTextSpan(selectionRange.textSpan),
      parent: selectionRange.parent ? SmartSelection.convertSelectionRange(selectionRange.parent) : void 0
    };
  }
};
var smartSelect_default = SmartSelection;

// src/server/features/tagClosing.ts
var import_coc16 = __toModule(require("coc.nvim"));
var TagClosing2 = class {
  constructor(client, descriptionLanguageId) {
    this.client = client;
    this.descriptionLanguageId = descriptionLanguageId;
    this._disposables = [];
    this._enabled = false;
    this._disposed = false;
    this._timeout = void 0;
    this._cancel = void 0;
    import_coc16.workspace.onDidChangeTextDocument((event) => this.onDidChangeTextDocument(event.textDocument, event.contentChanges), null, this._disposables);
    this.updateEnabledState();
    import_coc16.workspace.registerAutocmd({
      event: ["BufEnter"],
      request: false,
      callback: () => this.updateEnabledState()
    });
  }
  async updateEnabledState() {
    this._enabled = false;
    const doc = await import_coc16.workspace.document;
    if (!doc) {
      return;
    }
    const document = doc.textDocument;
    const configLang = TagClosing2._configurationLanguages[document.languageId];
    if (!configLang || configLang !== this.descriptionLanguageId) {
      return;
    }
    if (!import_coc16.workspace.getConfiguration(void 0, document.uri).get(`${configLang}.autoClosingTags`)) {
      return;
    }
    this._enabled = true;
  }
  dispose() {
    this._disposed = true;
    if (this._timeout) {
      clearTimeout(this._timeout);
      this._timeout = void 0;
    }
    if (this._cancel) {
      this._cancel.cancel();
      this._cancel.dispose();
      this._cancel = void 0;
    }
    import_coc16.disposeAll(this._disposables);
    this._disposables = [];
  }
  async onDidChangeTextDocument(documentEvent, changes) {
    if (!this._enabled) {
      return;
    }
    const document = await import_coc16.workspace.document;
    if (!document) {
      return;
    }
    const activeDocument = document.textDocument;
    if (activeDocument.uri !== documentEvent.uri || changes.length === 0) {
      return;
    }
    const filepath = this.client.toOpenedFilePath(documentEvent.uri);
    if (!filepath) {
      return;
    }
    if (typeof this._timeout !== "undefined") {
      clearTimeout(this._timeout);
    }
    if (this._cancel) {
      this._cancel.cancel();
      this._cancel.dispose();
      this._cancel = void 0;
    }
    const lastChange = changes[changes.length - 1];
    if (!import_coc16.Range.is(lastChange["range"]) || !lastChange.text) {
      return;
    }
    const lastCharacter = lastChange.text[lastChange.text.length - 1];
    if (lastCharacter !== ">" && lastCharacter !== "/") {
      return;
    }
    const version = documentEvent.version;
    const rangeStart = lastChange["range"].start;
    const priorCharacter = lastChange["range"].start.character > 0 ? activeDocument.getText(import_coc16.Range.create(import_coc16.Position.create(rangeStart.line, rangeStart.character - 1), rangeStart)) : "";
    if (priorCharacter === ">") {
      return;
    }
    this._timeout = setTimeout(async () => {
      this._timeout = void 0;
      if (this._disposed) {
        return;
      }
      const addedLines = lastChange.text.split(/\r\n|\n/g);
      const position = addedLines.length <= 1 ? import_coc16.Position.create(rangeStart.line, rangeStart.character + lastChange.text.length) : import_coc16.Position.create(rangeStart.line + addedLines.length - 1, addedLines[addedLines.length - 1].length);
      const args = Position.toFileLocationRequestArgs(filepath, position);
      this._cancel = new import_coc16.CancellationTokenSource();
      const response = await this.client.execute("jsxClosingTag", args, this._cancel.token);
      if (response.type !== "response" || !response.body) {
        return;
      }
      if (this._disposed) {
        return;
      }
      const insertion = response.body;
      if (documentEvent.uri === activeDocument.uri && activeDocument.version === version) {
        import_coc16.snippetManager.insertSnippet(this.getTagSnippet(insertion).value, false, import_coc16.Range.create(position, position));
      }
    }, 100);
  }
  getTagSnippet(closingTag) {
    const snippet = new SnippetString_default();
    snippet.appendPlaceholder("", 0);
    snippet.appendText(closingTag.newText);
    return snippet;
  }
};
var TagClosing = TagClosing2;
TagClosing.minVersion = api_default.v300;
TagClosing._configurationLanguages = {
  javascriptreact: "javascript",
  typescriptreact: "typescript"
};
var tagClosing_default = TagClosing;

// src/server/features/updatePathOnRename.ts
var import_coc17 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol16 = __toModule(require_main3());

// src/server/utils/mutex.ts
var Mutex = class {
  constructor() {
    this.tasks = [];
    this.count = 1;
  }
  sched() {
    if (this.count > 0 && this.tasks.length > 0) {
      this.count--;
      let next = this.tasks.shift();
      next();
    }
  }
  get busy() {
    return this.count == 0;
  }
  acquire() {
    return new Promise((res) => {
      let task = () => {
        let released = false;
        res(() => {
          if (!released) {
            released = true;
            this.count++;
            this.sched();
          }
        });
      };
      this.tasks.push(task);
      process.nextTick(this.sched.bind(this));
    });
  }
  use(f) {
    return this.acquire().then((release) => {
      return f().then((res) => {
        release();
        return res;
      }).catch((err) => {
        release();
        throw err;
      });
    });
  }
};

// src/server/features/updatePathOnRename.ts
function wait(ms) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
}
var UpdateImportsOnFileRenameHandler = class {
  constructor(client, fileConfigurationManager, languageId) {
    this.client = client;
    this.fileConfigurationManager = fileConfigurationManager;
    this.disposables = [];
    let glob = languageId == "typescript" ? "**/*.{ts,tsx}" : "**/*.{js,jsx}";
    const watcher = import_coc17.workspace.createFileSystemWatcher(glob);
    this.disposables.push(watcher);
    let mutex = new Mutex();
    watcher.onDidRename(async (e) => {
      let release = await mutex.acquire();
      try {
        await this.doRename(e.oldUri, e.newUri);
        release();
      } catch (e2) {
        this.client.logger.error("Error on rename:", e2);
        release();
      }
    }, null, this.disposables);
  }
  dispose() {
    import_coc17.disposeAll(this.disposables);
  }
  async doRename(oldResource, newResource) {
    if (oldResource.scheme !== "file" || newResource.scheme !== "file") {
      return;
    }
    const targetFile = newResource.fsPath;
    const oldFile = oldResource.fsPath;
    const newUri = newResource.toString();
    let oldDocument = import_coc17.workspace.getDocument(oldResource.toString());
    if (oldDocument) {
      await import_coc17.workspace.nvim.command(`silent ${oldDocument.bufnr}bwipeout!`);
    }
    let document = import_coc17.workspace.getDocument(newUri);
    if (document) {
      await import_coc17.workspace.nvim.command(`silent ${document.bufnr}bwipeout!`);
      await wait(30);
    }
    document = await import_coc17.workspace.loadFile(newUri);
    if (!document)
      return;
    await wait(50);
    const edits = await this.getEditsForFileRename(document.textDocument, oldFile, targetFile);
    if (!edits)
      return;
    if (await this.promptUser(newResource)) {
      await import_coc17.workspace.applyEdit(edits);
    }
  }
  async promptUser(newResource) {
    return await import_coc17.window.showPrompt(`Update imports for moved file: ${newResource.fsPath}?`);
  }
  async getEditsForFileRename(document, oldFile, newFile) {
    await this.fileConfigurationManager.ensureConfigurationForDocument(document, import_vscode_languageserver_protocol16.CancellationToken.None);
    const response = await this.client.interruptGetErr(() => {
      const args = {
        oldFilePath: oldFile,
        newFilePath: newFile
      };
      return this.client.execute("getEditsForFileRename", args, import_vscode_languageserver_protocol16.CancellationToken.None);
    });
    if (!response || response.type != "response" || !response.body) {
      return;
    }
    const edits = [];
    for (const edit of response.body) {
      if (edit.fileName.match(/[\/\\]node_modules[\/\\]/gi)) {
        continue;
      }
      for (const change of edit.textChanges) {
        if (change.newText.match(/\/node_modules\//gi)) {
          continue;
        }
      }
      edits.push(edit);
    }
    return WorkspaceEdit.fromFileCodeEdits(this.client, edits);
  }
};
var updatePathOnRename_default = UpdateImportsOnFileRenameHandler;

// src/server/organizeImports.ts
var import_coc18 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol17 = __toModule(require_main3());
var OrganizeImportsCommand = class {
  constructor(service) {
    this.service = service;
    this.id = "tsserver.organizeImports";
  }
  async _execute(client, document) {
    let file2 = client.toPath(document.uri);
    const args = {
      scope: {
        type: "file",
        args: {
          file: file2
        }
      }
    };
    const response = await client.interruptGetErr(() => client.execute("organizeImports", args, import_vscode_languageserver_protocol17.CancellationToken.None));
    if (!response || response.type != "response" || !response.success) {
      return;
    }
    const edit = WorkspaceEdit.fromFileCodeEdits(client, response.body);
    let keys = Object.keys(edit.changes);
    if (keys.length == 1) {
      let doc = import_coc18.workspace.getDocument(keys[0]);
      if (doc) {
        await doc.applyEdits(edit.changes[keys[0]]);
        return;
      }
    }
    if (edit)
      await import_coc18.workspace.applyEdit(edit);
  }
  async execute(document) {
    let client = await this.service.getClientHost();
    if (!document) {
      let doc = await import_coc18.workspace.document;
      if (!doc.attached) {
        throw new Error(`Document not attached.`);
      }
      if (client.serviceClient.modeIds.indexOf(doc.filetype) == -1) {
        throw new Error(`filetype "${doc.filetype}" not supported by tsserver.`);
      }
      document = doc.textDocument;
    }
    await this._execute(client.serviceClient, document);
  }
};
var OrganizeImportsCodeActionProvider = class {
  constructor(client, fileConfigManager) {
    this.client = client;
    this.fileConfigManager = fileConfigManager;
    this.metadata = {
      providedCodeActionKinds: [import_vscode_languageserver_protocol17.CodeActionKind.SourceOrganizeImports]
    };
  }
  async provideCodeActions(document, _range, context, token) {
    if (this.client.modeIds.indexOf(document.languageId) == -1)
      return;
    if (!context.only || !context.only.includes(import_vscode_languageserver_protocol17.CodeActionKind.SourceOrganizeImports)) {
      return [];
    }
    await this.fileConfigManager.ensureConfigurationForDocument(document, token);
    const action = import_vscode_languageserver_protocol17.CodeAction.create("Organize Imports", {
      title: "",
      command: "tsserver.organizeImports",
      arguments: [document]
    }, import_vscode_languageserver_protocol17.CodeActionKind.SourceOrganizeImports);
    return [action];
  }
};

// src/server/languageProvider.ts
var suggestionSetting = "suggestionActions.enabled";
var LanguageProvider = class {
  constructor(client, fileConfigurationManager, description, typingsStatus) {
    this.client = client;
    this.fileConfigurationManager = fileConfigurationManager;
    this.description = description;
    this.typingsStatus = typingsStatus;
    this.disposables = [];
    import_coc19.workspace.onDidChangeConfiguration(this.configurationChanged, this, this.disposables);
    this.configurationChanged();
    let initialized = false;
    client.onTsServerStarted(async () => {
      if (!initialized) {
        initialized = true;
        this.registerProviders(client, typingsStatus);
      }
    });
  }
  configurationChanged() {
    const config = import_coc19.workspace.getConfiguration(this.id, null);
    this.client.diagnosticsManager.setEnableSuggestions(this.id, config.get(suggestionSetting, true));
  }
  dispose() {
    import_coc19.disposeAll(this.disposables);
  }
  _register(disposable) {
    this.disposables.push(disposable);
  }
  registerProviders(client, typingsStatus) {
    let languageIds = this.description.modeIds;
    let clientId = `tsserver-${this.description.id}`;
    this._register(import_coc19.languages.registerCompletionItemProvider(clientId, "TSC", languageIds, new completionItemProvider_default(client, typingsStatus, this.fileConfigurationManager, this.description.id), completionItemProvider_default.triggerCharacters));
    if (this.client.apiVersion.gte(api_default.v230)) {
      this._register(import_coc19.languages.registerCompletionItemProvider(`${this.description.id}-directive`, "TSC", languageIds, new directiveCommentCompletions_default(client), ["@"]));
    }
    let definitionProvider = new definitionProvider_default(client);
    this._register(import_coc19.languages.registerDefinitionProvider(languageIds, definitionProvider));
    this._register(import_coc19.languages.registerTypeDefinitionProvider(languageIds, definitionProvider));
    this._register(import_coc19.languages.registerImplementationProvider(languageIds, definitionProvider));
    this._register(import_coc19.languages.registerReferencesProvider(languageIds, new references_default(client)));
    this._register(import_coc19.languages.registerHoverProvider(languageIds, new hover_default(client)));
    this._register(import_coc19.languages.registerDocumentHighlightProvider(languageIds, new documentHighlight_default(this.client)));
    this._register(import_coc19.languages.registerSignatureHelpProvider(languageIds, new signatureHelp_default(client), ["(", ",", "<", ")"]));
    this._register(import_coc19.languages.registerDocumentSymbolProvider(languageIds, new documentSymbol_default(client)));
    this._register(import_coc19.languages.registerRenameProvider(languageIds, new rename_default(client, this.fileConfigurationManager)));
    let formatProvider = new formatting_default(client, this.fileConfigurationManager);
    this._register(import_coc19.languages.registerDocumentFormatProvider(languageIds, formatProvider));
    this._register(import_coc19.languages.registerDocumentRangeFormatProvider(languageIds, formatProvider));
    this._register(import_coc19.languages.registerOnTypeFormattingEditProvider(languageIds, formatProvider, [";", "}", "\n", String.fromCharCode(27)]));
    this._register(import_coc19.languages.registerCodeActionProvider(languageIds, new moduleInstall_default(client), "tsserver"));
    let {fileConfigurationManager} = this;
    let conf = fileConfigurationManager.getLanguageConfiguration(this.id);
    if (["javascript", "typescript"].includes(this.id)) {
      if (this.client.apiVersion.gte(api_default.v290) && conf.get("updateImportsOnFileMove.enable")) {
        this._register(new updatePathOnRename_default(client, this.fileConfigurationManager, this.id));
      }
    }
    if (this.client.apiVersion.gte(api_default.v280)) {
      this._register(import_coc19.languages.registerFoldingRangeProvider(languageIds, new folding_default(this.client)));
      this._register(import_coc19.languages.registerCodeActionProvider(languageIds, new OrganizeImportsCodeActionProvider(this.client, this.fileConfigurationManager), "tsserver", [import_vscode_languageserver_protocol18.CodeActionKind.SourceOrganizeImports]));
    }
    if (this.client.apiVersion.gte(api_default.v240)) {
      this._register(import_coc19.languages.registerCodeActionProvider(languageIds, new refactor_default(client, this.fileConfigurationManager), "tsserver", [import_vscode_languageserver_protocol18.CodeActionKind.Refactor]));
    }
    this._register(import_coc19.languages.registerCodeActionProvider(languageIds, new quickfix_default(client, this.fileConfigurationManager), "tsserver", [import_vscode_languageserver_protocol18.CodeActionKind.QuickFix]));
    this._register(import_coc19.languages.registerCodeActionProvider(languageIds, new importFix_default(this.client.bufferSyncSupport), "tsserver", [import_vscode_languageserver_protocol18.CodeActionKind.QuickFix]));
    let cachedResponse = new CachedNavTreeResponse();
    if (this.client.apiVersion.gte(api_default.v206) && conf.get("referencesCodeLens.enable")) {
      this._register(import_coc19.languages.registerCodeLensProvider(languageIds, new referencesCodeLens_default(client, cachedResponse)));
    }
    if (this.client.apiVersion.gte(api_default.v220) && conf.get("implementationsCodeLens.enable")) {
      this._register(import_coc19.languages.registerCodeLensProvider(languageIds, new implementationsCodeLens_default(client, cachedResponse)));
    }
    if (this.client.apiVersion.gte(api_default.v350)) {
      this._register(import_coc19.languages.registerSelectionRangeProvider(languageIds, new smartSelect_default(this.client)));
    }
    if (this.client.apiVersion.gte(api_default.v300)) {
      this._register(new tagClosing_default(this.client, this.description.id));
    }
  }
  handles(resource, doc) {
    if (doc && this.description.modeIds.indexOf(doc.languageId) >= 0) {
      return true;
    }
    const base = import_path4.default.basename(import_coc19.Uri.parse(resource).fsPath);
    return !!base && (!!this.description.configFilePattern && this.description.configFilePattern.test(base));
  }
  get id() {
    return this.description.id;
  }
  get diagnosticSource() {
    return this.description.diagnosticSource;
  }
  triggerAllDiagnostics() {
    this.client.bufferSyncSupport.requestAllDiagnostics();
  }
  diagnosticsReceived(diagnosticsKind, file2, diagnostics) {
    const config = import_coc19.workspace.getConfiguration(this.id, file2.toString());
    const reportUnnecessary = config.get("showUnused", true);
    this.client.diagnosticsManager.diagnosticsReceived(diagnosticsKind, file2.toString(), diagnostics.filter((diag) => {
      if (!reportUnnecessary) {
        diag.tags = void 0;
        if (diag.reportUnnecessary && diag.severity === import_vscode_languageserver_protocol18.DiagnosticSeverity.Information) {
          return false;
        }
      }
      return true;
    }));
  }
};
var languageProvider_default = LanguageProvider;

// src/server/typescriptServiceClient.ts
var import_coc28 = __toModule(require("coc.nvim"));
var import_fs4 = __toModule(require("fs"));
var import_os2 = __toModule(require("os"));
var import_path7 = __toModule(require("path"));
var import_vscode_languageserver_protocol20 = __toModule(require_main3());

// src/utils/fileSchemess.ts
var file = "file";
var git = "git";
var vsls = "vsls";
var disabledSchemes = new Set([
  git,
  vsls
]);

// src/server/typescriptService.ts
var ServerResponse;
(function(ServerResponse2) {
  class Cancelled {
    constructor(reason) {
      this.reason = reason;
      this.type = "cancelled";
    }
  }
  ServerResponse2.Cancelled = Cancelled;
  ServerResponse2.NoContent = new class {
    constructor() {
      this.type = "noContent";
    }
  }();
})(ServerResponse || (ServerResponse = {}));
var ExectuionTarget;
(function(ExectuionTarget2) {
  ExectuionTarget2[ExectuionTarget2["Semantic"] = 0] = "Semantic";
  ExectuionTarget2[ExectuionTarget2["Syntax"] = 1] = "Syntax";
})(ExectuionTarget || (ExectuionTarget = {}));

// src/server/callbackMap.ts
var CallbackMap = class {
  constructor() {
    this._callbacks = new Map();
    this._asyncCallbacks = new Map();
  }
  destroy(cause) {
    const cancellation = new ServerResponse.Cancelled(cause);
    for (const callback of this._callbacks.values()) {
      callback.onSuccess(cancellation);
    }
    this._callbacks.clear();
    for (const callback of this._asyncCallbacks.values()) {
      callback.onSuccess(cancellation);
    }
    this._asyncCallbacks.clear();
  }
  add(seq, callback, isAsync) {
    if (isAsync) {
      this._asyncCallbacks.set(seq, callback);
    } else {
      this._callbacks.set(seq, callback);
    }
  }
  fetch(seq) {
    const callback = this._callbacks.get(seq) || this._asyncCallbacks.get(seq);
    this.delete(seq);
    return callback;
  }
  delete(seq) {
    if (!this._callbacks.delete(seq)) {
      this._asyncCallbacks.delete(seq);
    }
  }
};

// src/server/features/bufferSyncSupport.ts
var import_coc21 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol19 = __toModule(require_main3());

// src/server/utils/async.ts
var Delayer = class {
  constructor(defaultDelay) {
    this.defaultDelay = defaultDelay;
    this.timeout = null;
    this.completionPromise = null;
    this.onSuccess = null;
    this.task = null;
  }
  trigger(task, delay = this.defaultDelay) {
    this.task = task;
    if (delay >= 0) {
      this.cancelTimeout();
    }
    if (!this.completionPromise) {
      this.completionPromise = new Promise((resolve) => {
        this.onSuccess = resolve;
      }).then(() => {
        this.completionPromise = null;
        this.onSuccess = null;
        let result = this.task && this.task();
        this.task = null;
        return result;
      });
    }
    if (delay >= 0 || this.timeout === null) {
      this.timeout = setTimeout(() => {
        this.timeout = null;
        if (this.onSuccess) {
          this.onSuccess(void 0);
        }
      }, delay >= 0 ? delay : this.defaultDelay);
    }
    return this.completionPromise;
  }
  cancelTimeout() {
    if (this.timeout !== null) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
};

// src/server/utils/languageModeIds.ts
var typescript = "typescript";
var typescriptreact = "typescriptreact";
var typescripttsx = "typescript.tsx";
var typescriptjsx = "typescript.jsx";
var javascript = "javascript";
var javascriptreact = "javascriptreact";
var javascriptjsx = "javascript.jsx";
function mode2ScriptKind(mode) {
  switch (mode) {
    case typescript:
      return "TS";
    case typescripttsx:
      return "TSX";
    case typescriptjsx:
      return "TSX";
    case typescriptreact:
      return "TSX";
    case javascript:
      return "JS";
    case javascriptreact:
      return "JSX";
  }
  return void 0;
}

// src/server/features/resourceMap.ts
var import_coc20 = __toModule(require("coc.nvim"));
function defaultPathNormalizer(resource) {
  let u = import_coc20.Uri.parse(resource);
  if (u.scheme === "file") {
    return u.fsPath;
  }
  return resource.toString();
}
var ResourceMap = class {
  constructor(_normalizePath = defaultPathNormalizer) {
    this._normalizePath = _normalizePath;
    this._map = new Map();
  }
  get size() {
    return this._map.size;
  }
  get entries() {
    return this._map.values();
  }
  has(uri) {
    const file2 = this.toKey(uri);
    return !!file2 && this._map.has(file2);
  }
  get(uri) {
    const file2 = this.toKey(uri);
    if (!file2)
      return void 0;
    let entry = this._map.get(file2);
    return entry ? entry.value : void 0;
  }
  set(uri, value) {
    const file2 = this.toKey(uri);
    if (file2) {
      this._map.set(file2, {uri, value});
    }
  }
  delete(uri) {
    const file2 = this.toKey(uri);
    if (file2) {
      this._map.delete(file2);
    }
  }
  get values() {
    return Array.from(this._map.values()).map((x) => x.value);
  }
  get uris() {
    return Array.from(this._map.values()).map((x) => x.uri);
  }
  clear() {
    this._map.clear();
  }
  toKey(uri) {
    const key = this._normalizePath ? this._normalizePath(uri) : uri;
    if (!key) {
      return key;
    }
    return this.isCaseInsensitivePath(key) ? key.toLowerCase() : key;
  }
  isCaseInsensitivePath(path8) {
    if (isWindowsPath(path8)) {
      return true;
    }
    return path8[0] === "/" && this.onIsCaseInsenitiveFileSystem;
  }
  get onIsCaseInsenitiveFileSystem() {
    if (process.platform === "win32") {
      return true;
    }
    if (process.platform === "darwin") {
      return true;
    }
    return false;
  }
};
function isWindowsPath(path8) {
  return /^[a-zA-Z]:\\/.test(path8);
}

// src/server/features/bufferSyncSupport.ts
var BufferKind;
(function(BufferKind2) {
  BufferKind2[BufferKind2["TypeScript"] = 1] = "TypeScript";
  BufferKind2[BufferKind2["JavaScript"] = 2] = "JavaScript";
})(BufferKind || (BufferKind = {}));
var BufferState;
(function(BufferState2) {
  BufferState2[BufferState2["Initial"] = 1] = "Initial";
  BufferState2[BufferState2["Open"] = 2] = "Open";
  BufferState2[BufferState2["Closed"] = 2] = "Closed";
})(BufferState || (BufferState = {}));
var BufferOperationType;
(function(BufferOperationType2) {
  BufferOperationType2[BufferOperationType2["Close"] = 0] = "Close";
  BufferOperationType2[BufferOperationType2["Open"] = 1] = "Open";
  BufferOperationType2[BufferOperationType2["Change"] = 2] = "Change";
})(BufferOperationType || (BufferOperationType = {}));
var CloseOperation = class {
  constructor(args) {
    this.args = args;
    this.type = 0;
  }
};
var OpenOperation = class {
  constructor(args) {
    this.args = args;
    this.type = 1;
  }
};
var ChangeOperation = class {
  constructor(args) {
    this.args = args;
    this.type = 2;
  }
};
var SyncedBuffer = class {
  constructor(document, filepath, client, synchronizer) {
    this.document = document;
    this.filepath = filepath;
    this.client = client;
    this.synchronizer = synchronizer;
    this.state = 1;
  }
  open() {
    const args = {
      file: this.filepath,
      fileContent: this.document.getText(),
      projectRootPath: this.client.getProjectRootPath(this.document.uri)
    };
    const scriptKind = mode2ScriptKind(this.document.languageId);
    if (scriptKind) {
      args.scriptKindName = scriptKind;
    }
    if (this.client.apiVersion.gte(api_default.v240)) {
      const tsPluginsForDocument = this.client.pluginManager.plugins.filter((x) => x.languages.indexOf(this.document.languageId) >= 0);
      if (tsPluginsForDocument.length) {
        args.plugins = tsPluginsForDocument.map((plugin) => plugin.name);
      }
    }
    this.synchronizer.open(this.resource, args);
    this.state = 2;
  }
  get resource() {
    return this.document.uri;
  }
  get lineCount() {
    return this.document.lineCount;
  }
  get kind() {
    if (this.document.languageId.startsWith("javascript")) {
      return 2;
    }
    return 1;
  }
  close() {
    if (this.state !== 2) {
      this.state = 2;
      return false;
    }
    this.state = 2;
    return this.synchronizer.close(this.resource, this.filepath);
  }
  onContentChanged(events2) {
    if (this.state !== 2) {
      console.error(`Unexpected buffer state: ${this.state}`);
    }
    this.synchronizer.change(this.resource, this.filepath, events2);
  }
};
var SyncedBufferMap = class extends ResourceMap {
  getForPath(filePath) {
    return this.get(import_coc21.Uri.file(filePath).toString());
  }
  get allBuffers() {
    return this.values;
  }
};
var PendingDiagnostics = class extends ResourceMap {
  getOrderedFileSet() {
    const orderedResources = Array.from(this.entries).sort((a, b) => a.value - b.value).map((entry) => entry.uri);
    const map = new ResourceMap(this._normalizePath);
    for (const resource of orderedResources) {
      map.set(resource, void 0);
    }
    return map;
  }
};
var BufferSynchronizer = class {
  constructor(client, pathNormalizer) {
    this.client = client;
    this._pending = new ResourceMap(pathNormalizer);
  }
  open(resource, args) {
    if (this.supportsBatching) {
      this.updatePending(resource, new OpenOperation(args));
    } else {
      this.client.executeWithoutWaitingForResponse("open", args);
    }
  }
  close(resource, filepath) {
    if (this.supportsBatching) {
      return this.updatePending(resource, new CloseOperation(filepath));
    } else {
      const args = {file: filepath};
      this.client.executeWithoutWaitingForResponse("close", args);
      return true;
    }
  }
  change(resource, filepath, events2) {
    if (!events2.length) {
      return;
    }
    if (this.supportsBatching) {
      this.updatePending(resource, new ChangeOperation({
        fileName: filepath,
        textChanges: events2.map((change) => ({
          newText: change.text,
          start: Position.toLocation(change.range.start),
          end: Position.toLocation(change.range.end)
        })).reverse()
      }));
    } else {
      for (const {range, text} of events2) {
        const args = {
          insertString: text,
          ...Range.toFormattingRequestArgs(filepath, range)
        };
        this.client.executeWithoutWaitingForResponse("change", args);
      }
    }
  }
  reset() {
    this._pending.clear();
  }
  beforeCommand(command) {
    if (command === "updateOpen") {
      return;
    }
    this.flush();
  }
  flush() {
    if (!this.supportsBatching) {
      this._pending.clear();
      return;
    }
    if (this._pending.size > 0) {
      const closedFiles = [];
      const openFiles = [];
      const changedFiles = [];
      for (const change of this._pending.values) {
        switch (change.type) {
          case 2:
            changedFiles.push(change.args);
            break;
          case 1:
            openFiles.push(change.args);
            break;
          case 0:
            closedFiles.push(change.args);
            break;
        }
      }
      this.client.execute("updateOpen", {changedFiles, closedFiles, openFiles}, import_vscode_languageserver_protocol19.CancellationToken.None, {nonRecoverable: true});
      this._pending.clear();
    }
  }
  get supportsBatching() {
    return this.client.apiVersion.gte(api_default.v340);
  }
  updatePending(resource, op) {
    switch (op.type) {
      case 0:
        const existing = this._pending.get(resource);
        switch (existing == null ? void 0 : existing.type) {
          case 1:
            this._pending.delete(resource);
            return false;
        }
        break;
    }
    if (this._pending.has(resource)) {
      this.flush();
    }
    this._pending.set(resource, op);
    return true;
  }
};
var GetErrRequest = class {
  constructor(client, uris, _token, onDone) {
    this.uris = uris;
    this._token = _token;
    this._done = false;
    let files = uris.map((uri) => client.normalizePath(uri));
    const args = {
      delay: 0,
      files
    };
    const done = () => {
      if (this._done) {
        return;
      }
      this._done = true;
      onDone();
    };
    client.executeAsync("geterr", args, _token.token).then(done, done);
  }
  static executeGetErrRequest(client, uris, onDone) {
    const token = new import_vscode_languageserver_protocol19.CancellationTokenSource();
    return new GetErrRequest(client, uris, token, onDone);
  }
  cancel() {
    if (!this._done) {
      this._token.cancel();
    }
    this._token.dispose();
  }
};
var BufferSyncSupport = class {
  constructor(client, modeIds) {
    this.disposables = [];
    this._validateJavaScript = true;
    this._validateTypeScript = true;
    this.listening = false;
    this._onDelete = new import_vscode_languageserver_protocol19.Emitter();
    this.onDelete = this._onDelete.event;
    this._onWillChange = new import_vscode_languageserver_protocol19.Emitter();
    this.onWillChange = this._onWillChange.event;
    this.client = client;
    this.modeIds = new Set(modeIds);
    this.diagnosticDelayer = new Delayer(300);
    const pathNormalizer = (path8) => this.client.toPath(path8);
    this.syncedBuffers = new SyncedBufferMap(pathNormalizer);
    this.pendingDiagnostics = new PendingDiagnostics(pathNormalizer);
    this.synchronizer = new BufferSynchronizer(client, pathNormalizer);
    this.updateConfiguration();
    import_coc21.workspace.onDidChangeConfiguration(this.updateConfiguration, this, this.disposables);
  }
  listen() {
    if (this.listening) {
      return;
    }
    this.listening = true;
    import_coc21.workspace.onDidOpenTextDocument(this.openTextDocument, this, this.disposables);
    import_coc21.workspace.onDidCloseTextDocument(this.onDidCloseTextDocument, this, this.disposables);
    import_coc21.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, this.disposables);
    import_coc21.workspace.textDocuments.forEach(this.openTextDocument, this);
  }
  handles(resource) {
    return this.syncedBuffers.has(resource);
  }
  dispose() {
    this.pendingDiagnostics.clear();
    import_coc21.disposeAll(this.disposables);
    this._onWillChange.dispose();
    this._onDelete.dispose();
  }
  ensureHasBuffer(resource) {
    if (this.syncedBuffers.has(resource)) {
      return true;
    }
    const existingDocument = import_coc21.workspace.textDocuments.find((doc) => doc.uri.toString() === resource);
    if (existingDocument) {
      return this.openTextDocument(existingDocument);
    }
    return false;
  }
  toResource(filePath) {
    const buffer = this.syncedBuffers.getForPath(filePath);
    if (buffer)
      return buffer.resource;
    return import_coc21.Uri.file(filePath).toString();
  }
  reset() {
    var _a;
    (_a = this.pendingGetErr) == null ? void 0 : _a.cancel();
    this.pendingDiagnostics.clear();
    this.synchronizer.reset();
  }
  reinitialize() {
    this.reset();
    for (const buffer of this.syncedBuffers.allBuffers) {
      buffer.open();
    }
  }
  openTextDocument(document) {
    if (!this.modeIds.has(document.languageId)) {
      return false;
    }
    const resource = document.uri;
    const filepath = this.client.normalizePath(import_coc21.Uri.parse(resource));
    if (!filepath) {
      return false;
    }
    if (this.syncedBuffers.has(resource)) {
      return true;
    }
    const syncedBuffer = new SyncedBuffer(document, filepath, this.client, this.synchronizer);
    this.syncedBuffers.set(resource, syncedBuffer);
    syncedBuffer.open();
    this.requestDiagnostic(syncedBuffer);
    return true;
  }
  closeResource(resource) {
    const syncedBuffer = this.syncedBuffers.get(resource);
    if (!syncedBuffer) {
      return;
    }
    this.pendingDiagnostics.delete(resource);
    this.syncedBuffers.delete(resource);
    const wasBufferOpen = syncedBuffer.close();
    this._onDelete.fire(resource);
    if (wasBufferOpen) {
      this.requestAllDiagnostics();
    }
  }
  onDidCloseTextDocument(document) {
    this.closeResource(document.uri);
  }
  onDidChangeTextDocument(e) {
    const syncedBuffer = this.syncedBuffers.get(e.textDocument.uri);
    if (!syncedBuffer) {
      return;
    }
    this._onWillChange.fire(syncedBuffer.resource);
    syncedBuffer.onContentChanged(e.contentChanges);
    const didTrigger = this.requestDiagnostic(syncedBuffer);
    if (!didTrigger && this.pendingGetErr) {
      this.pendingGetErr.cancel();
      this.pendingGetErr = void 0;
      this.triggerDiagnostics();
    }
  }
  beforeCommand(command) {
    this.synchronizer.beforeCommand(command);
  }
  interuptGetErr(f) {
    if (!this.pendingGetErr) {
      return f();
    }
    this.pendingGetErr.cancel();
    this.pendingGetErr = void 0;
    const result = f();
    this.triggerDiagnostics();
    return result;
  }
  getErr(resources) {
    const handledResources = resources.filter((resource) => {
      let syncedBuffer = this.syncedBuffers.get(resource.toString());
      return syncedBuffer && this.shouldValidate(syncedBuffer);
    });
    if (!handledResources.length) {
      return;
    }
    for (const resource of handledResources) {
      this.pendingDiagnostics.set(resource.toString(), Date.now());
    }
    this.triggerDiagnostics();
  }
  triggerDiagnostics(delay = 200) {
    this.diagnosticDelayer.trigger(() => {
      this.sendPendingDiagnostics();
    }, delay);
  }
  requestAllDiagnostics() {
    for (const buffer of this.syncedBuffers.allBuffers) {
      if (this.shouldValidate(buffer)) {
        this.pendingDiagnostics.set(buffer.resource, Date.now());
      }
    }
    this.triggerDiagnostics();
  }
  requestDiagnostic(buffer) {
    if (!this.shouldValidate(buffer)) {
      return false;
    }
    this.pendingDiagnostics.set(buffer.resource, Date.now());
    const delay = Math.min(Math.max(Math.ceil(buffer.lineCount / 20), 300), 800);
    this.triggerDiagnostics(delay);
    return true;
  }
  hasPendingDiagnostics(uri) {
    return this.pendingDiagnostics.has(uri);
  }
  sendPendingDiagnostics() {
    const orderedFileSet = this.pendingDiagnostics.getOrderedFileSet();
    if (this.pendingGetErr) {
      this.pendingGetErr.cancel();
      for (const uri of this.pendingGetErr.uris) {
        let resource = uri.toString();
        let syncedBuffer = this.syncedBuffers.get(resource);
        if (syncedBuffer && this.shouldValidate(syncedBuffer)) {
          orderedFileSet.set(resource, void 0);
        } else {
          orderedFileSet.delete(resource);
        }
      }
      this.pendingGetErr = void 0;
    }
    for (const buffer of this.syncedBuffers.values) {
      if (this.shouldValidate(buffer)) {
        orderedFileSet.set(buffer.resource, void 0);
      }
    }
    if (orderedFileSet.size) {
      let uris = Array.from(orderedFileSet.uris).map((uri) => import_coc21.Uri.parse(uri));
      const getErr = this.pendingGetErr = GetErrRequest.executeGetErrRequest(this.client, uris, () => {
        if (this.pendingGetErr === getErr) {
          this.pendingGetErr = void 0;
        }
      });
    }
    this.pendingDiagnostics.clear();
  }
  updateConfiguration() {
    const jsConfig = import_coc21.workspace.getConfiguration("javascript", null);
    const tsConfig = import_coc21.workspace.getConfiguration("typescript", null);
    this._validateJavaScript = jsConfig.get("validate.enable", true);
    this._validateTypeScript = tsConfig.get("validate.enable", true);
  }
  shouldValidate(buffer) {
    switch (buffer.kind) {
      case 2:
        return this._validateJavaScript;
      case 1:
      default:
        return this._validateTypeScript;
    }
  }
};
var bufferSyncSupport_default = BufferSyncSupport;

// src/server/features/diagnostics.ts
var import_coc22 = __toModule(require("coc.nvim"));
var DiagnosticSet = class {
  constructor() {
    this._map = new ResourceMap();
  }
  set(uri, diagnostics) {
    this._map.set(uri, diagnostics);
  }
  get(uri) {
    return this._map.get(uri) || [];
  }
  clear() {
    this._map = new ResourceMap();
  }
};
var DiagnosticKind;
(function(DiagnosticKind2) {
  DiagnosticKind2[DiagnosticKind2["Syntax"] = 0] = "Syntax";
  DiagnosticKind2[DiagnosticKind2["Semantic"] = 1] = "Semantic";
  DiagnosticKind2[DiagnosticKind2["Suggestion"] = 2] = "Suggestion";
})(DiagnosticKind || (DiagnosticKind = {}));
var allDiagnosticKinds = [
  0,
  1,
  2
];
var DiagnosticsManager = class {
  constructor() {
    this._diagnostics = new Map();
    this._pendingUpdates = new ResourceMap();
    this._enableJavascriptSuggestions = true;
    this._enableTypescriptSuggestions = true;
    this.updateDelay = 200;
    for (const kind of allDiagnosticKinds) {
      this._diagnostics.set(kind, new DiagnosticSet());
    }
    this._currentDiagnostics = import_coc22.languages.createDiagnosticCollection("tsserver");
  }
  dispose() {
    this._currentDiagnostics.dispose();
    for (const value of this._pendingUpdates.values) {
      clearTimeout(value);
    }
    this._pendingUpdates = new ResourceMap();
  }
  reInitialize() {
    this._currentDiagnostics.clear();
    for (const diagnosticSet of this._diagnostics.values()) {
      diagnosticSet.clear();
    }
  }
  setEnableSuggestions(languageId, value) {
    let curr = languageId == "javascript" ? this._enableJavascriptSuggestions : this._enableTypescriptSuggestions;
    if (curr == value) {
      return;
    }
    if (languageId == "javascript") {
      this._enableJavascriptSuggestions = value;
    } else {
      this._enableTypescriptSuggestions = value;
    }
  }
  diagnosticsReceived(kind, uri, diagnostics) {
    const collection = this._diagnostics.get(kind);
    if (!collection)
      return;
    let doc = import_coc22.workspace.getDocument(uri);
    if (doc)
      uri = doc.uri;
    if (diagnostics.length === 0) {
      const existing = collection.get(uri);
      if (existing.length === 0) {
        return;
      }
    }
    collection.set(uri, diagnostics);
    this.scheduleDiagnosticsUpdate(uri);
  }
  configFileDiagnosticsReceived(uri, diagnostics) {
    this._currentDiagnostics.set(uri, diagnostics);
  }
  delete(uri) {
    this._currentDiagnostics.delete(uri);
  }
  getDiagnostics(uri) {
    return this._currentDiagnostics.get(uri) || [];
    return [];
  }
  scheduleDiagnosticsUpdate(uri) {
    if (!this._pendingUpdates.has(uri)) {
      this._pendingUpdates.set(uri, setTimeout(() => this.updateCurrentDiagnostics(uri), this.updateDelay));
    }
  }
  updateCurrentDiagnostics(uri) {
    if (this._pendingUpdates.has(uri)) {
      clearTimeout(this._pendingUpdates.get(uri));
      this._pendingUpdates.delete(uri);
    }
    const allDiagnostics = [
      ...this._diagnostics.get(0).get(uri),
      ...this._diagnostics.get(1).get(uri),
      ...this.getSuggestionDiagnostics(uri)
    ];
    this._currentDiagnostics.set(uri, allDiagnostics);
  }
  getSuggestionDiagnostics(uri) {
    const enabled = this.suggestionsEnabled(uri);
    return this._diagnostics.get(2).get(uri).filter((x) => {
      if (!enabled) {
        return x.code == 6133;
      }
      return enabled;
    });
  }
  suggestionsEnabled(uri) {
    let doc = import_coc22.workspace.getDocument(uri);
    if (!doc)
      return false;
    if (doc.filetype.startsWith("javascript")) {
      return this._enableJavascriptSuggestions;
    }
    if (doc.filetype.startsWith("typescript")) {
      return this._enableTypescriptSuggestions;
    }
    return true;
  }
};

// src/server/requestQueue.ts
var RequestQueueingType;
(function(RequestQueueingType2) {
  RequestQueueingType2[RequestQueueingType2["Normal"] = 1] = "Normal";
  RequestQueueingType2[RequestQueueingType2["LowPriority"] = 2] = "LowPriority";
  RequestQueueingType2[RequestQueueingType2["Fence"] = 3] = "Fence";
})(RequestQueueingType || (RequestQueueingType = {}));
var RequestQueue = class {
  constructor() {
    this.queue = [];
    this.sequenceNumber = 0;
  }
  get length() {
    return this.queue.length;
  }
  enqueue(item) {
    if (item.queueingType === 1) {
      let index = this.queue.length - 1;
      while (index >= 0) {
        if (this.queue[index].queueingType !== 2) {
          break;
        }
        --index;
      }
      this.queue.splice(index + 1, 0, item);
    } else {
      this.queue.push(item);
    }
  }
  dequeue() {
    return this.queue.shift();
  }
  tryDeletePendingRequest(seq) {
    for (let i = 0; i < this.queue.length; i++) {
      if (this.queue[i].request.seq === seq) {
        this.queue.splice(i, 1);
        return true;
      }
    }
    return false;
  }
  createRequest(command, args) {
    return {
      seq: this.sequenceNumber++,
      type: "request",
      command,
      arguments: args
    };
  }
};

// src/server/utils/configuration.ts
var import_coc23 = __toModule(require("coc.nvim"));
var import_which = __toModule(require_which());
var TsServerLogLevel;
(function(TsServerLogLevel2) {
  TsServerLogLevel2[TsServerLogLevel2["Off"] = 0] = "Off";
  TsServerLogLevel2[TsServerLogLevel2["Normal"] = 1] = "Normal";
  TsServerLogLevel2[TsServerLogLevel2["Terse"] = 2] = "Terse";
  TsServerLogLevel2[TsServerLogLevel2["Verbose"] = 3] = "Verbose";
})(TsServerLogLevel || (TsServerLogLevel = {}));
(function(TsServerLogLevel2) {
  function fromString(value) {
    switch (value && value.toLowerCase()) {
      case "normal":
        return TsServerLogLevel2.Normal;
      case "terse":
        return TsServerLogLevel2.Terse;
      case "verbose":
        return TsServerLogLevel2.Verbose;
      case "off":
      default:
        return TsServerLogLevel2.Off;
    }
  }
  TsServerLogLevel2.fromString = fromString;
  function toString2(value) {
    switch (value) {
      case TsServerLogLevel2.Normal:
        return "normal";
      case TsServerLogLevel2.Terse:
        return "terse";
      case TsServerLogLevel2.Verbose:
        return "verbose";
      case TsServerLogLevel2.Off:
      default:
        return "off";
    }
  }
  TsServerLogLevel2.toString = toString2;
})(TsServerLogLevel || (TsServerLogLevel = {}));
var TypeScriptServiceConfiguration = class {
  constructor() {
    this._configuration = import_coc23.workspace.getConfiguration("tsserver");
    import_coc23.workspace.onDidChangeConfiguration(() => {
      this._configuration = import_coc23.workspace.getConfiguration("tsserver");
    });
  }
  get locale() {
    return this._configuration.get("locale", null);
  }
  get globalTsdk() {
    return this._configuration.get("tsdk", null);
  }
  get ignoreLocalTsserver() {
    return this._configuration.get("ignoreLocalTsserver", false);
  }
  get tsServerLogLevel() {
    return TsServerLogLevel.fromString(this._configuration.get("log", null));
  }
  get watchOptions() {
    return this._configuration.get("watchOptions");
  }
  get typingsCacheLocation() {
    return this._configuration.get("typingsCacheLocation", "");
  }
  get tsServerPluginPaths() {
    return this._configuration.get("pluginPaths", []);
  }
  get checkJs() {
    return this._configuration.get("implicitProjectConfig.checkJs", false);
  }
  get experimentalDecorators() {
    return this._configuration.get("implicitProjectConfig.experimentalDecorators", false);
  }
  get disableAutomaticTypeAcquisition() {
    return this._configuration.get("disableAutomaticTypeAcquisition", false);
  }
  get formatOnType() {
    return this._configuration.get("formatOnType", false);
  }
  get maxTsServerMemory() {
    return this._configuration.get("maxTsServerMemory", 0);
  }
  get debugPort() {
    return this._configuration.get("debugPort", parseInt(process.env["TSS_DEBUG"], 10));
  }
  get npmLocation() {
    let path8 = this._configuration.get("npm", "");
    if (path8)
      return import_coc23.workspace.expand(path8);
    try {
      path8 = import_which.default.sync("npm");
    } catch (e) {
      return null;
    }
    return path8;
  }
  static loadFromWorkspace() {
    return new TypeScriptServiceConfiguration();
  }
};

// src/server/utils/logger.ts
var import_coc24 = __toModule(require("coc.nvim"));

// src/server/utils/is.ts
var toString = Object.prototype.toString;
function boolean(value) {
  return value === true || value === false;
}
function string(value) {
  return toString.call(value) === "[object String]";
}

// src/server/utils/logger.ts
var Logger = class {
  get output() {
    if (this._channel) {
      return this._channel;
    }
    this._channel = import_coc24.window.createOutputChannel("tsserver");
    return this._channel;
  }
  dispose() {
    if (this._channel) {
      this._channel.dispose();
    }
  }
  data2String(data) {
    if (data instanceof Error) {
      if (string(data.stack)) {
        return data.stack;
      }
      return data.message;
    }
    if (boolean(data.success) && !data.success && string(data.message)) {
      return data.message;
    }
    if (string(data)) {
      return data;
    }
    return data.toString();
  }
  info(message, data) {
    this.logLevel("Info", message, data);
  }
  warn(message, data) {
    this.logLevel("Warn", message, data);
  }
  error(message, data) {
    if (data && data.message === "No content available.") {
      return;
    }
    this.logLevel("Error", message, data);
  }
  logLevel(level, message, data) {
    this.output.appendLine(`[${level}  - ${new Date().toLocaleTimeString()}] ${message}`);
    if (data) {
      this.output.appendLine(this.data2String(data));
    }
  }
};
var logger_default = Logger;

// src/server/utils/process.ts
var import_child_process2 = __toModule(require("child_process"));
var import_net = __toModule(require("net"));
var import_os = __toModule(require("os"));
var import_path5 = __toModule(require("path"));
var import_fs2 = __toModule(require("fs"));
function makeRandomHexString(length) {
  let chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
  let result = "";
  for (let i = 0; i < length; i++) {
    const idx = Math.floor(chars.length * Math.random());
    result += chars[idx];
  }
  return result;
}
function getTempDirectory() {
  let dir = import_path5.default.join(import_os.default.tmpdir(), `coc.nvim-${process.pid}`);
  if (!import_fs2.default.existsSync(dir)) {
    import_fs2.default.mkdirSync(dir);
  }
  return dir;
}
function generatePipeName() {
  return getPipeName(makeRandomHexString(40));
}
function getPipeName(name) {
  const fullName = "coc-tsc-" + name;
  if (process.platform === "win32") {
    return "\\\\.\\pipe\\" + fullName + "-sock";
  }
  const tmpdir = getTempDirectory();
  return import_path5.default.join(tmpdir, fullName + ".sock");
}
function getTempFile(name) {
  const fullName = "coc-nvim-" + name;
  return import_path5.default.join(getTempDirectory(), fullName + ".sock");
}
function generatePatchedEnv(env, stdInPipeName, stdOutPipeName, stdErrPipeName) {
  const newEnv = Object.assign({}, env);
  newEnv["STDIN_PIPE_NAME"] = stdInPipeName;
  newEnv["STDOUT_PIPE_NAME"] = stdOutPipeName;
  newEnv["STDERR_PIPE_NAME"] = stdErrPipeName;
  newEnv["TSS_LOG"] = `-level verbose -file ${import_path5.default.join(import_os.default.tmpdir(), "coc-nvim-tsc.log")}`;
  newEnv["PATH"] = newEnv["PATH"] || process.env.PATH;
  return newEnv;
}
function fork(modulePath, args, options, logger, callback) {
  let callbackCalled = false;
  const resolve = (result) => {
    if (callbackCalled) {
      return;
    }
    callbackCalled = true;
    callback(null, result);
  };
  const reject = (err) => {
    if (callbackCalled) {
      return;
    }
    callbackCalled = true;
    callback(err, null);
  };
  const stdInPipeName = generatePipeName();
  const stdOutPipeName = generatePipeName();
  const stdErrPipeName = generatePipeName();
  const newEnv = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);
  newEnv["NODE_PATH"] = import_path5.default.join(modulePath, "..", "..", "..");
  let childProcess;
  let stdErrServer = import_net.default.createServer((stdErrStream) => {
    childProcess.stderr = stdErrStream;
  });
  stdErrServer.listen(stdErrPipeName);
  let stdOutServer = import_net.default.createServer((stdOutStream) => {
    stdOutStream.once("data", (_chunk) => {
      childProcess.stdin = import_net.default.connect(stdInPipeName);
      childProcess.stdout = stdOutStream;
      resolve(childProcess);
    });
  });
  stdOutServer.listen(stdOutPipeName);
  let serverClosed = false;
  const closeServer = () => {
    if (serverClosed) {
      return;
    }
    serverClosed = true;
    stdOutServer.close();
    stdErrServer.close();
  };
  logger.info("Forking TSServer", `PATH: ${newEnv["PATH"]} `);
  const bootstrapperPath = import_path5.default.resolve(__dirname, "../bin/tsserverForkStart");
  childProcess = import_child_process2.default.fork(bootstrapperPath, [modulePath].concat(args), {
    silent: true,
    env: newEnv,
    execArgv: options.execArgv
  });
  childProcess.once("error", (err) => {
    closeServer();
    reject(err);
  });
  childProcess.once("exit", (err) => {
    closeServer();
    reject(err);
  });
}

// src/server/utils/tracer.ts
var import_coc25 = __toModule(require("coc.nvim"));
var Trace;
(function(Trace2) {
  Trace2[Trace2["Off"] = 0] = "Off";
  Trace2[Trace2["Messages"] = 1] = "Messages";
  Trace2[Trace2["Verbose"] = 2] = "Verbose";
})(Trace || (Trace = {}));
(function(Trace2) {
  function fromString(value) {
    value = value || "";
    value = value.toLowerCase();
    switch (value) {
      case "off":
        return Trace2.Off;
      case "messages":
        return Trace2.Messages;
      case "verbose":
        return Trace2.Verbose;
      default:
        return Trace2.Off;
    }
  }
  Trace2.fromString = fromString;
})(Trace || (Trace = {}));
var Tracer = class {
  constructor(logger) {
    this.logger = logger;
    this.trace = Tracer.readTrace();
  }
  static readTrace() {
    let result = Trace.fromString(import_coc25.workspace.getConfiguration("tsserver").get("trace.server", "off"));
    if (result === 0 && !!process.env.TSS_TRACE) {
      result = 1;
    }
    return result;
  }
  traceRequest(request, responseExpected, queueLength) {
    if (this.trace === 0)
      return;
    let data;
    if (this.trace === 2 && request.arguments) {
      data = `Arguments: ${JSON.stringify(request.arguments, null, 4)}`;
    }
    this.logTrace(`Sending request: ${request.command} (${request.seq}). Response expected: ${responseExpected ? "yes" : "no"}. Current queue length: ${queueLength}`, data);
  }
  traceResponse(response, startTime) {
    if (this.trace === 0) {
      return;
    }
    let data;
    if (this.trace === 2 && response.body) {
      data = `Result: ${JSON.stringify(response.body, null, 4)}`;
    }
    this.logTrace(`Response received: ${response.command} (${response.request_seq}). Request took ${Date.now() - startTime} ms. Success: ${response.success} ${!response.success ? ". Message: " + response.message : ""}`, data);
  }
  traceEvent(event) {
    if (this.trace === 0) {
      return;
    }
    let data;
    if (this.trace === 2 && event.body) {
      data = `Data: ${JSON.stringify(event.body, null, 4)}`;
    }
    this.logTrace(`Event received: ${event.event} (${event.seq}).`, data);
  }
  logTrace(message, data) {
    if (this.trace !== 0) {
      this.logger.logLevel("Trace", message, data);
    }
  }
  traceRequestCompleted(command, request_seq, startTime) {
    if (this.trace === 0) {
      return;
    }
    this.logTrace(`Async response received: ${command} (${request_seq}). Request took ${Date.now() - startTime} ms.`);
  }
};
var tracer_default = Tracer;

// src/server/utils/tsconfig.ts
function inferredProjectConfig(config) {
  const base = {
    module: "commonjs",
    target: "es2016",
    jsx: "preserve"
  };
  if (config.checkJs) {
    base.checkJs = true;
  }
  if (config.experimentalDecorators) {
    base.experimentalDecorators = true;
  }
  return base;
}

// src/server/utils/versionProvider.ts
var import_coc26 = __toModule(require("coc.nvim"));
var import_fs3 = __toModule(require("fs"));
var import_path6 = __toModule(require("path"));
var TypeScriptVersion = class {
  constructor(path8, _pathLabel) {
    this.path = path8;
    this._pathLabel = _pathLabel;
    this._api = null;
  }
  get tscPath() {
    return import_path6.default.resolve(this.path, "../bin/tsc");
  }
  get tsServerPath() {
    return import_path6.default.resolve(this.path, "tsserver.js");
  }
  get pathLabel() {
    return typeof this._pathLabel === "undefined" ? this.path : this._pathLabel;
  }
  get isValid() {
    return this.version != null;
  }
  get version() {
    if (this._api)
      return this._api;
    let api = this._api = this.getTypeScriptVersion(this.tsServerPath);
    return api;
  }
  get versionString() {
    const version = this.version;
    return version ? version.versionString : null;
  }
  getTypeScriptVersion(serverPath) {
    if (!import_fs3.default.existsSync(serverPath)) {
      return void 0;
    }
    const p = serverPath.split(import_path6.default.sep);
    if (p.length <= 2) {
      return void 0;
    }
    const p2 = p.slice(0, -2);
    const modulePath = p2.join(import_path6.default.sep);
    let fileName = import_path6.default.join(modulePath, "package.json");
    if (!import_fs3.default.existsSync(fileName)) {
      if (import_path6.default.basename(modulePath) === "built") {
        fileName = import_path6.default.join(modulePath, "..", "package.json");
      }
    }
    if (!import_fs3.default.existsSync(fileName)) {
      return void 0;
    }
    const contents = import_fs3.default.readFileSync(fileName).toString();
    let desc = null;
    try {
      desc = JSON.parse(contents);
    } catch (err) {
      return void 0;
    }
    if (!desc || !desc.version) {
      return void 0;
    }
    return desc.version ? api_default.fromVersionString(desc.version) : void 0;
  }
};
var MODULE_FOLDERS = ["node_modules/typescript/lib", ".vscode/pnpify/typescript/lib", ".yarn/sdks/typescript/lib"];
var TypeScriptVersionProvider = class {
  constructor(configuration) {
    this.configuration = configuration;
  }
  updateConfiguration(configuration) {
    this.configuration = configuration;
  }
  getDefaultVersion() {
    let {globalTsdk} = this.configuration;
    if (globalTsdk)
      return new TypeScriptVersion(globalTsdk);
    return this.bundledVersion;
  }
  get globalVersion() {
    let {globalTsdk} = this.configuration;
    if (globalTsdk)
      return new TypeScriptVersion(import_coc26.workspace.expand(globalTsdk));
    return void 0;
  }
  getLocalVersion() {
    let folders = import_coc26.workspace.workspaceFolders.map((f) => import_coc26.Uri.parse(f.uri).fsPath);
    for (let p of folders) {
      for (let folder of MODULE_FOLDERS) {
        let libFolder = import_path6.default.join(p, folder);
        if (import_fs3.default.existsSync(libFolder)) {
          let version = new TypeScriptVersion(libFolder);
          if (version.isValid)
            return version;
        }
      }
    }
    return null;
  }
  get bundledVersion() {
    try {
      const file2 = require.resolve("typescript");
      const bundledVersion = new TypeScriptVersion(import_path6.default.dirname(file2), "");
      return bundledVersion;
    } catch (e) {
      import_coc26.window.showMessage("Bundled typescript module not found", "error");
      return null;
    }
  }
};

// src/server/utils/versionStatus.ts
var import_coc27 = __toModule(require("coc.nvim"));
var VersionStatus = class {
  constructor(_normalizePath, enableJavascript) {
    this._normalizePath = _normalizePath;
    this.enableJavascript = enableJavascript;
    this._versionString = "";
    this._versionBarEntry = import_coc27.window.createStatusBarItem(99);
    this._onChangeEditorSub = import_coc27.events.on("BufEnter", this.onBufEnter, this);
    this._versionBarEntry.show();
  }
  dispose() {
    this._versionBarEntry.dispose();
    this._onChangeEditorSub.dispose();
  }
  onDidChangeTypeScriptVersion(version) {
    this._versionString = version.versionString;
  }
  set loading(isLoading) {
    if (isLoading) {
      this._versionBarEntry.text = `Initializing tsserver ${this._versionString}`;
    } else {
      this._versionBarEntry.text = `TSC ${this._versionString}`;
    }
    this._versionBarEntry.isProgress = isLoading;
  }
  checkFiletype(filetype) {
    if (filetype.startsWith("javascript") && this.enableJavascript) {
      return true;
    }
    return filetype.startsWith("typescript");
  }
  async onBufEnter(bufnr) {
    let filetype = await import_coc27.workspace.nvim.call("getbufvar", [bufnr, "&filetype", ""]);
    if (this.checkFiletype(filetype)) {
      this._versionBarEntry.show();
    } else {
      this._versionBarEntry.hide();
    }
  }
};
var versionStatus_default = VersionStatus;

// src/server/utils/wireProtocol.ts
var DefaultSize = 8192;
var ContentLength = "Content-Length: ";
var ContentLengthSize = Buffer.byteLength(ContentLength, "utf8");
var Blank = Buffer.from(" ", "utf8")[0];
var BackslashR = Buffer.from("\r", "utf8")[0];
var BackslashN = Buffer.from("\n", "utf8")[0];
var ProtocolBuffer = class {
  constructor() {
    this.index = 0;
    this.buffer = Buffer.allocUnsafe(DefaultSize);
  }
  append(data) {
    let toAppend = null;
    if (Buffer.isBuffer(data)) {
      toAppend = data;
    } else {
      toAppend = Buffer.from(data, "utf8");
    }
    if (this.buffer.length - this.index >= toAppend.length) {
      toAppend.copy(this.buffer, this.index, 0, toAppend.length);
    } else {
      let newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
      if (this.index === 0) {
        this.buffer = Buffer.allocUnsafe(newSize);
        toAppend.copy(this.buffer, 0, 0, toAppend.length);
      } else {
        this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
      }
    }
    this.index += toAppend.length;
  }
  tryReadContentLength() {
    let result = -1;
    let current = 0;
    while (current < this.index && (this.buffer[current] === Blank || this.buffer[current] === BackslashR || this.buffer[current] === BackslashN)) {
      current++;
    }
    if (this.index < current + ContentLengthSize) {
      return result;
    }
    current += ContentLengthSize;
    let start = current;
    while (current < this.index && this.buffer[current] !== BackslashR) {
      current++;
    }
    if (current + 3 >= this.index || this.buffer[current + 1] !== BackslashN || this.buffer[current + 2] !== BackslashR || this.buffer[current + 3] !== BackslashN) {
      return result;
    }
    let data = this.buffer.toString("utf8", start, current);
    result = parseInt(data, 10);
    this.buffer = this.buffer.slice(current + 4);
    this.index = this.index - (current + 4);
    return result;
  }
  tryReadContent(length) {
    if (this.index < length) {
      return null;
    }
    let result = this.buffer.toString("utf8", 0, length);
    let sourceStart = length;
    while (sourceStart < this.index && (this.buffer[sourceStart] === BackslashR || this.buffer[sourceStart] === BackslashN)) {
      sourceStart++;
    }
    this.buffer.copy(this.buffer, 0, sourceStart);
    this.index = this.index - sourceStart;
    return result;
  }
};
var Reader = class {
  constructor(readable, callback, onError) {
    this.readable = readable;
    this.callback = callback;
    this.onError = onError;
    this.buffer = new ProtocolBuffer();
    this.nextMessageLength = -1;
    this.readable.on("data", (data) => {
      this.onLengthData(data);
    });
  }
  onLengthData(data) {
    try {
      this.buffer.append(data);
      while (true) {
        if (this.nextMessageLength === -1) {
          this.nextMessageLength = this.buffer.tryReadContentLength();
          if (this.nextMessageLength === -1) {
            return;
          }
        }
        const msg = this.buffer.tryReadContent(this.nextMessageLength);
        if (msg === null) {
          return;
        }
        this.nextMessageLength = -1;
        const json = JSON.parse(msg);
        this.callback(json);
      }
    } catch (e) {
      this.onError(e);
    }
  }
};

// src/server/typescriptServiceClient.ts
var ForkedTsServerProcess = class {
  constructor(childProcess) {
    this.childProcess = childProcess;
    this.toCancelOnResourceChange = new Set();
  }
  onError(cb) {
    this.childProcess.on("error", cb);
  }
  onExit(cb) {
    this.childProcess.on("exit", cb);
  }
  write(serverRequest) {
    this.childProcess.stdin.write(JSON.stringify(serverRequest) + "\r\n", "utf8");
  }
  createReader(callback, onError) {
    new Reader(this.childProcess.stdout, callback, onError);
  }
  kill() {
    this.childProcess.kill();
  }
};
var TypeScriptServiceClient = class {
  constructor(pluginManager, modeIds) {
    this.pluginManager = pluginManager;
    this.modeIds = modeIds;
    this.state = import_coc28.ServiceStat.Initial;
    this.logger = new logger_default();
    this.tsServerLogFile = null;
    this.cancellationPipeName = null;
    this._callbacks = new CallbackMap();
    this._requestQueue = new RequestQueue();
    this._pendingResponses = new Set();
    this._onTsServerStarted = new import_vscode_languageserver_protocol20.Emitter();
    this._onProjectLanguageServiceStateChanged = new import_vscode_languageserver_protocol20.Emitter();
    this._onDidBeginInstallTypings = new import_vscode_languageserver_protocol20.Emitter();
    this._onDidEndInstallTypings = new import_vscode_languageserver_protocol20.Emitter();
    this._onTypesInstallerInitializationFailed = new import_vscode_languageserver_protocol20.Emitter();
    this.disposables = [];
    this.isRestarting = false;
    this._onDiagnosticsReceived = new import_vscode_languageserver_protocol20.Emitter();
    this._onConfigDiagnosticsReceived = new import_vscode_languageserver_protocol20.Emitter();
    this._onResendModelsRequested = new import_vscode_languageserver_protocol20.Emitter();
    this.pathSeparator = import_path7.default.sep;
    this.lastStart = Date.now();
    this.servicePromise = null;
    this.lastError = null;
    this.numberRestarts = 0;
    this.fileConfigurationManager = new fileConfigurationManager_default(this);
    this._configuration = TypeScriptServiceConfiguration.loadFromWorkspace();
    this.versionProvider = new TypeScriptVersionProvider(this._configuration);
    this._apiVersion = api_default.defaultVersion;
    this.tracer = new tracer_default(this.logger);
    this.versionStatus = new versionStatus_default(this.normalizePath.bind(this), this.fileConfigurationManager.enableJavascript());
    pluginManager.onDidUpdateConfig((update) => {
      this.configurePlugin(update.pluginId, update.config);
    }, null, this.disposables);
    pluginManager.onDidChangePlugins(() => {
      this.restartTsServer();
    }, null, this.disposables);
    this.bufferSyncSupport = new bufferSyncSupport_default(this, modeIds);
    this.onTsServerStarted(() => {
      this.bufferSyncSupport.listen();
    });
    this.diagnosticsManager = new DiagnosticsManager();
    this.bufferSyncSupport.onDelete((resource) => {
      this.cancelInflightRequestsForResource(resource);
      this.diagnosticsManager.delete(resource);
    }, null, this.disposables);
    this.bufferSyncSupport.onWillChange((resource) => {
      this.cancelInflightRequestsForResource(resource);
    });
  }
  get onDiagnosticsReceived() {
    return this._onDiagnosticsReceived.event;
  }
  get onConfigDiagnosticsReceived() {
    return this._onConfigDiagnosticsReceived.event;
  }
  get onResendModelsRequested() {
    return this._onResendModelsRequested.event;
  }
  get configuration() {
    return this._configuration;
  }
  dispose() {
    if (this.servicePromise) {
      this.servicePromise.then((childProcess) => {
        childProcess.kill();
      }).then(void 0, () => void 0);
    }
    this.bufferSyncSupport.dispose();
    this.logger.dispose();
    this._onTsServerStarted.dispose();
    this._onResendModelsRequested.dispose();
    this.versionStatus.dispose();
  }
  info(message, data) {
    this.logger.info(message, data);
  }
  error(message, data) {
    this.logger.error(message, data);
  }
  restartTsServer() {
    const start = () => {
      this.servicePromise = this.startService(true);
      return this.servicePromise;
    };
    if (this.servicePromise) {
      return Promise.resolve(this.servicePromise.then((childProcess) => {
        this.state = import_coc28.ServiceStat.Stopping;
        this.info("Killing TS Server");
        this.isRestarting = true;
        childProcess.kill();
        this.servicePromise = null;
      }).then(start));
    } else {
      return Promise.resolve(start());
    }
  }
  stop() {
    if (!this.servicePromise)
      return;
    return new Promise((resolve, reject) => {
      this.servicePromise.then((childProcess) => {
        if (this.state == import_coc28.ServiceStat.Running) {
          this.info("Killing TS Server");
          childProcess.onExit(() => {
            resolve();
          });
          childProcess.kill();
          this.servicePromise = null;
        } else {
          resolve();
        }
      }, reject);
    });
  }
  get onTsServerStarted() {
    return this._onTsServerStarted.event;
  }
  get onProjectLanguageServiceStateChanged() {
    return this._onProjectLanguageServiceStateChanged.event;
  }
  get onDidBeginInstallTypings() {
    return this._onDidBeginInstallTypings.event;
  }
  get onDidEndInstallTypings() {
    return this._onDidEndInstallTypings.event;
  }
  get onTypesInstallerInitializationFailed() {
    return this._onTypesInstallerInitializationFailed.event;
  }
  get apiVersion() {
    return this._apiVersion;
  }
  get tscPath() {
    return this._tscPath;
  }
  service() {
    if (this.servicePromise) {
      return this.servicePromise;
    }
    if (this.lastError) {
      return Promise.reject(this.lastError);
    }
    return this.startService().then(() => {
      if (this.servicePromise) {
        return this.servicePromise;
      }
    });
  }
  ensureServiceStarted() {
    if (!this.servicePromise) {
      this.startService().catch((err) => {
        import_coc28.window.showMessage(`TSServer start failed: ${err.message}`, "error");
        this.error(`Service start failed: ${err.stack}`);
      });
    }
  }
  async startService(resendModels = false) {
    const {ignoreLocalTsserver} = this.configuration;
    let currentVersion;
    if (!ignoreLocalTsserver)
      currentVersion = this.versionProvider.getLocalVersion();
    if (!currentVersion || !import_fs4.default.existsSync(currentVersion.tsServerPath)) {
      currentVersion = this.versionProvider.getDefaultVersion();
    }
    if (!currentVersion || !currentVersion.isValid) {
      if (this.configuration.globalTsdk) {
        import_coc28.window.showMessage(`Can not find typescript module, in 'tsserver.tsdk': ${this.configuration.globalTsdk}`, "error");
      } else {
        import_coc28.window.showMessage(`Can not find typescript module, run ':CocInstall coc-tsserver' to fix it!`, "error");
      }
      return;
    }
    this._apiVersion = currentVersion.version;
    this._tscPath = currentVersion.tscPath;
    this.versionStatus.onDidChangeTypeScriptVersion(currentVersion);
    this.lastError = null;
    const tsServerForkArgs = await this.getTsServerArgs(currentVersion);
    const debugPort = this._configuration.debugPort;
    const maxTsServerMemory = this._configuration.maxTsServerMemory;
    const options = {
      execArgv: [
        ...debugPort ? [`--inspect=${debugPort}`] : [],
        ...maxTsServerMemory ? [`--max-old-space-size=${maxTsServerMemory}`] : []
      ],
      cwd: import_coc28.workspace.root
    };
    this.servicePromise = this.startProcess(currentVersion, tsServerForkArgs, options, resendModels);
    return this.servicePromise;
  }
  startProcess(currentVersion, args, options, resendModels) {
    this.state = import_coc28.ServiceStat.Starting;
    return new Promise((resolve, reject) => {
      try {
        fork(currentVersion.tsServerPath, args, options, this.logger, (err, childProcess) => {
          if (err || !childProcess) {
            this.state = import_coc28.ServiceStat.StartFailed;
            this.lastError = err;
            this.error("Starting TSServer failed with error.", err.stack);
            return;
          }
          this.state = import_coc28.ServiceStat.Running;
          this.info("Started TSServer", JSON.stringify(currentVersion, null, 2));
          const handle = new ForkedTsServerProcess(childProcess);
          this.tsServerProcess = handle;
          this.lastStart = Date.now();
          handle.onError((err2) => {
            this.lastError = err2;
            this.error("TSServer errored with error.", err2);
            this.error(`TSServer log file: ${this.tsServerLogFile || ""}`);
            import_coc28.window.showMessage(`TSServer errored with error. ${err2.message}`, "error");
            this.serviceExited(false);
          });
          handle.onExit((code) => {
            if (code == null) {
              this.info("TSServer normal exit");
            } else {
              this.error(`TSServer exited with code: ${code}`);
            }
            this.info(`TSServer log file: ${this.tsServerLogFile || ""}`);
            this.serviceExited(!this.isRestarting);
            this.isRestarting = false;
          });
          handle.createReader((msg) => {
            this.dispatchMessage(msg);
          }, (error) => {
            this.error("ReaderError", error);
          });
          resolve(handle);
          this.serviceStarted(resendModels);
          this._onTsServerStarted.fire(currentVersion.version);
        });
      } catch (e) {
        reject(e);
      }
    });
  }
  async openTsServerLogFile() {
    const isRoot = process.getuid && process.getuid() == 0;
    let echoErr = (msg) => {
      import_coc28.window.showMessage(msg, "error");
    };
    if (isRoot) {
      echoErr("Log disabled for root user.");
      return false;
    }
    if (!this.apiVersion.gte(api_default.v222)) {
      echoErr("TS Server logging requires TS 2.2.2+");
      return false;
    }
    if (this._configuration.tsServerLogLevel === TsServerLogLevel.Off) {
      echoErr(`TS Server logging is off. Change 'tsserver.log' in 'coc-settings.json' to enable`);
      return false;
    }
    if (!this.tsServerLogFile) {
      echoErr("TS Server has not started logging.");
      return false;
    }
    try {
      await import_coc28.workspace.nvim.command(`edit ${this.tsServerLogFile}`);
      return true;
    } catch {
      echoErr("Could not open TS Server log file");
      return false;
    }
  }
  serviceStarted(resendModels) {
    this.bufferSyncSupport.reset();
    const watchOptions = this.apiVersion.gte(api_default.v380) ? this.configuration.watchOptions : void 0;
    const configureOptions = {
      hostInfo: "coc-nvim",
      preferences: {
        providePrefixAndSuffixTextForRename: true,
        allowRenameOfImportPath: true
      },
      watchOptions
    };
    this.executeWithoutWaitingForResponse("configure", configureOptions);
    this.setCompilerOptionsForInferredProjects(this._configuration);
    if (resendModels) {
      this._onResendModelsRequested.fire(void 0);
      this.fileConfigurationManager.reset();
      this.diagnosticsManager.reInitialize();
      this.bufferSyncSupport.reinitialize();
    }
    for (const [config, pluginName] of this.pluginManager.configurations()) {
      this.configurePlugin(config, pluginName);
    }
  }
  setCompilerOptionsForInferredProjects(configuration) {
    if (!this.apiVersion.gte(api_default.v206))
      return;
    const args = {
      options: this.getCompilerOptionsForInferredProjects(configuration)
    };
    this.executeWithoutWaitingForResponse("compilerOptionsForInferredProjects", args);
  }
  getCompilerOptionsForInferredProjects(configuration) {
    return {
      ...inferredProjectConfig(configuration),
      allowJs: true,
      allowSyntheticDefaultImports: true,
      allowNonTsExtensions: true
    };
  }
  serviceExited(restart) {
    this.state = import_coc28.ServiceStat.Stopped;
    this.servicePromise = null;
    this.tsServerLogFile = null;
    this._callbacks.destroy("Service died.");
    this._callbacks = new CallbackMap();
    this._requestQueue = new RequestQueue();
    this._pendingResponses = new Set();
    if (restart) {
      const diff = Date.now() - this.lastStart;
      this.numberRestarts++;
      let startService = true;
      if (this.numberRestarts > 5) {
        this.numberRestarts = 0;
        if (diff < 10 * 1e3) {
          this.lastStart = Date.now();
          startService = false;
          import_coc28.window.showMessage("The TypeScript language service died 5 times right after it got started.", "error");
        } else if (diff < 60 * 1e3) {
          this.lastStart = Date.now();
          import_coc28.window.showMessage("The TypeScript language service died unexpectedly 5 times in the last 5 Minutes.", "error");
        }
      }
      if (startService) {
        this.startService(true);
      }
    }
  }
  toPath(uri) {
    return this.normalizePath(import_coc28.Uri.parse(uri));
  }
  toOpenedFilePath(uri, options = {}) {
    if (!this.bufferSyncSupport.ensureHasBuffer(uri)) {
      if (!options.suppressAlertOnFailure) {
        console.error(`Unexpected resource ${uri}`);
      }
      return void 0;
    }
    return this.toPath(uri);
  }
  toResource(filepath) {
    if (this._apiVersion.gte(api_default.v213)) {
      if (filepath.startsWith(this.inMemoryResourcePrefix + "untitled:")) {
        let resource = import_coc28.Uri.parse(filepath);
        if (this.inMemoryResourcePrefix) {
          const dirName = import_path7.default.dirname(resource.path);
          const fileName = import_path7.default.basename(resource.path);
          if (fileName.startsWith(this.inMemoryResourcePrefix)) {
            resource = resource.with({path: import_path7.default.posix.join(dirName, fileName.slice(this.inMemoryResourcePrefix.length))});
          }
        }
        return resource.toString();
      }
    }
    return import_coc28.Uri.file(filepath).toString();
  }
  normalizePath(resource) {
    if (disabledSchemes.has(resource.scheme)) {
      return void 0;
    }
    switch (resource.scheme) {
      case file: {
        let result = resource.fsPath;
        if (!result)
          return void 0;
        result = import_path7.default.normalize(result);
        return result.replace(new RegExp("\\" + this.pathSeparator, "g"), "/");
      }
      default: {
        return this.inMemoryResourcePrefix + resource.toString(true);
      }
    }
  }
  getDocument(resource) {
    if (resource.startsWith("untitled:")) {
      let bufnr = parseInt(resource.split(":", 2)[1], 10);
      return import_coc28.workspace.getDocument(bufnr);
    }
    return import_coc28.workspace.getDocument(resource);
  }
  get inMemoryResourcePrefix() {
    return this._apiVersion.gte(api_default.v270) ? "^" : "";
  }
  asUrl(filepath) {
    if (this._apiVersion.gte(api_default.v213)) {
      if (filepath.startsWith(this.inMemoryResourcePrefix + "untitled:")) {
        let resource = import_coc28.Uri.parse(filepath.slice(this.inMemoryResourcePrefix.length));
        if (this.inMemoryResourcePrefix) {
          const dirName = import_path7.default.dirname(resource.path);
          const fileName = import_path7.default.basename(resource.path);
          if (fileName.startsWith(this.inMemoryResourcePrefix)) {
            resource = resource.with({
              path: import_path7.default.posix.join(dirName, fileName.slice(this.inMemoryResourcePrefix.length))
            });
          }
        }
        return resource;
      }
    }
    return import_coc28.Uri.file(filepath);
  }
  execute(command, args, token, config) {
    var _a;
    let execution;
    if (config == null ? void 0 : config.cancelOnResourceChange) {
      const source = new import_vscode_languageserver_protocol20.CancellationTokenSource();
      token.onCancellationRequested(() => source.cancel());
      const inFlight = {
        resource: config.cancelOnResourceChange,
        cancel: () => source.cancel()
      };
      (_a = this.tsServerProcess) == null ? void 0 : _a.toCancelOnResourceChange.add(inFlight);
      execution = this.executeImpl(command, args, {
        isAsync: false,
        token: source.token,
        expectsResult: true,
        ...config
      }).finally(() => {
        var _a2;
        (_a2 = this.tsServerProcess) == null ? void 0 : _a2.toCancelOnResourceChange.delete(inFlight);
        source.dispose();
      });
    } else {
      execution = this.executeImpl(command, args, {
        isAsync: false,
        token,
        expectsResult: true,
        ...config
      });
    }
    if (config == null ? void 0 : config.nonRecoverable) {
      execution.catch((err) => this.fatalError(command, err));
    }
    return execution;
  }
  fatalError(command, error) {
    console.error(`A non-recoverable error occured while executing tsserver command: ${command}`);
    if (this.state === import_coc28.ServiceStat.Running) {
      this.info("Killing TS Server by fatal error:", error);
      this.service().then((service) => {
        service.kill();
      });
    }
  }
  executeAsync(command, args, token) {
    return this.executeImpl(command, args, {
      isAsync: true,
      token,
      expectsResult: true
    });
  }
  executeWithoutWaitingForResponse(command, args) {
    this.executeImpl(command, args, {
      isAsync: false,
      token: void 0,
      expectsResult: false
    });
  }
  executeImpl(command, args, executeInfo) {
    if (this.servicePromise == null) {
      return Promise.resolve(void 0);
    }
    this.bufferSyncSupport.beforeCommand(command);
    const request = this._requestQueue.createRequest(command, args);
    const requestInfo = {
      request,
      expectsResponse: executeInfo.expectsResult,
      isAsync: executeInfo.isAsync,
      queueingType: getQueueingType(command, executeInfo.lowPriority)
    };
    let result;
    if (executeInfo.expectsResult) {
      result = new Promise((resolve, reject) => {
        this._callbacks.add(request.seq, {onSuccess: resolve, onError: reject, startTime: Date.now(), isAsync: executeInfo.isAsync}, executeInfo.isAsync);
        if (executeInfo.token) {
          executeInfo.token.onCancellationRequested(() => {
            this.tryCancelRequest(request.seq, command);
          });
        }
      }).catch((err) => {
        throw err;
      });
    }
    this._requestQueue.enqueue(requestInfo);
    this.sendNextRequests();
    return result;
  }
  sendNextRequests() {
    while (this._pendingResponses.size === 0 && this._requestQueue.length > 0) {
      const item = this._requestQueue.dequeue();
      if (item) {
        this.sendRequest(item);
      }
    }
  }
  sendRequest(requestItem) {
    const serverRequest = requestItem.request;
    this.tracer.traceRequest(serverRequest, requestItem.expectsResponse, this._requestQueue.length);
    if (requestItem.expectsResponse && !requestItem.isAsync) {
      this._pendingResponses.add(requestItem.request.seq);
    }
    this.service().then((childProcess) => {
      try {
        childProcess.write(serverRequest);
      } catch (err) {
        const callback = this.fetchCallback(serverRequest.seq);
        if (callback) {
          callback.onError(err);
        }
      }
    });
  }
  tryCancelRequest(seq, command) {
    try {
      if (this._requestQueue.tryDeletePendingRequest(seq)) {
        this.tracer.logTrace(`TypeScript Server: canceled request with sequence number ${seq}`);
        return true;
      }
      if (this.cancellationPipeName) {
        this.tracer.logTrace(`TypeScript Server: trying to cancel ongoing request with sequence number ${seq}`);
        try {
          import_fs4.default.writeFileSync(this.cancellationPipeName + seq, "");
        } catch {
        }
        return true;
      }
      this.tracer.logTrace(`TypeScript Server: tried to cancel request with sequence number ${seq}. But request got already delivered.`);
      return false;
    } finally {
      const callback = this.fetchCallback(seq);
      if (callback) {
        callback.onSuccess(new ServerResponse.Cancelled(`Cancelled request ${seq} - ${command}`));
      }
    }
  }
  fetchCallback(seq) {
    const callback = this._callbacks.fetch(seq);
    if (!callback) {
      return void 0;
    }
    this._pendingResponses.delete(seq);
    return callback;
  }
  dispatchMessage(message) {
    try {
      switch (message.type) {
        case "response":
          this.dispatchResponse(message);
          break;
        case "event":
          const event = message;
          if (event.event === "requestCompleted") {
            const seq = event.body.request_seq;
            const p = this._callbacks.fetch(seq);
            if (p) {
              this.tracer.traceRequestCompleted("requestCompleted", seq, p.startTime);
              p.onSuccess(void 0);
            }
          } else {
            this.tracer.traceEvent(event);
            this.dispatchEvent(event);
          }
          break;
        default:
          throw new Error(`Unknown message type ${message.type} received`);
      }
    } finally {
      this.sendNextRequests();
    }
  }
  dispatchResponse(response) {
    const callback = this.fetchCallback(response.request_seq);
    if (!callback) {
      return;
    }
    this.tracer.traceResponse(response, callback.startTime);
    if (response.success) {
      callback.onSuccess(response);
    } else if (response.message === "No content available.") {
      callback.onSuccess(ServerResponse.NoContent);
    } else {
      callback.onError(new Error(response.message));
    }
  }
  dispatchEvent(event) {
    switch (event.event) {
      case "syntaxDiag":
      case "semanticDiag":
      case "suggestionDiag":
        const diagnosticEvent = event;
        if (diagnosticEvent.body && diagnosticEvent.body.diagnostics) {
          this._onDiagnosticsReceived.fire({
            kind: getDiagnosticsKind(event),
            resource: this.asUrl(diagnosticEvent.body.file),
            diagnostics: diagnosticEvent.body.diagnostics
          });
        }
        break;
      case "configFileDiag":
        this._onConfigDiagnosticsReceived.fire(event);
        break;
      case "projectLanguageServiceState":
        if (event.body) {
          this._onProjectLanguageServiceStateChanged.fire(event.body);
        }
        break;
      case "beginInstallTypes":
        if (event.body) {
          this._onDidBeginInstallTypings.fire(event.body);
        }
        break;
      case "endInstallTypes":
        if (event.body) {
          this._onDidEndInstallTypings.fire(event.body);
        }
        break;
      case "projectsUpdatedInBackground":
        const body = event.body;
        const resources = body.openFiles.map(import_coc28.Uri.file);
        this.bufferSyncSupport.getErr(resources);
        break;
      case "typesInstallerInitializationFailed":
        if (event.body) {
          this._onTypesInstallerInitializationFailed.fire(event.body);
        }
        break;
      case "projectLoadingStart":
        this.versionStatus.loading = true;
        break;
      case "projectLoadingFinish":
        this.versionStatus.loading = false;
        break;
    }
  }
  async getTsServerArgs(currentVersion) {
    const args = [];
    args.push("--allowLocalPluginLoads");
    if (this.apiVersion.gte(api_default.v250)) {
      args.push("--useInferredProjectPerProjectRoot");
    } else {
      args.push("--useSingleInferredProject");
    }
    if (this.apiVersion.gte(api_default.v206) && this._configuration.disableAutomaticTypeAcquisition) {
      args.push("--disableAutomaticTypingAcquisition");
    }
    if (this.apiVersion.gte(api_default.v222)) {
      this.cancellationPipeName = getTempFile(`tscancellation-${makeRandomHexString(20)}`);
      args.push("--cancellationPipeName", this.cancellationPipeName + "*");
    }
    if (this.apiVersion.gte(api_default.v222)) {
      const isRoot = process.getuid && process.getuid() == 0;
      if (this._configuration.tsServerLogLevel !== TsServerLogLevel.Off && !isRoot) {
        const logDir = getTempDirectory();
        if (logDir) {
          this.tsServerLogFile = import_path7.default.join(logDir, `tsserver.log`);
          this.info("TSServer log file :", this.tsServerLogFile);
        } else {
          this.tsServerLogFile = null;
          this.error("Could not create TSServer log directory");
        }
        if (this.tsServerLogFile) {
          args.push("--logVerbosity", TsServerLogLevel.toString(this._configuration.tsServerLogLevel));
          args.push("--logFile", this.tsServerLogFile);
        }
      }
    }
    if (this.apiVersion.gte(api_default.v230)) {
      const pluginNames = this.pluginManager.plugins.map((x) => x.name);
      let pluginPaths = this._configuration.tsServerPluginPaths;
      pluginPaths = pluginPaths.reduce((p, c) => {
        if (import_path7.default.isAbsolute(c)) {
          p.push(c);
        } else {
          let roots = import_coc28.workspace.workspaceFolders.map((o) => import_coc28.Uri.parse(o.uri).fsPath);
          p.push(...roots.map((r) => import_path7.default.join(r, c)));
        }
        return p;
      }, []);
      if (pluginNames.length) {
        const isUsingBundledTypeScriptVersion = currentVersion.path == this.versionProvider.bundledVersion.path;
        args.push("--globalPlugins", pluginNames.join(","));
        for (const plugin of this.pluginManager.plugins) {
          if (isUsingBundledTypeScriptVersion || plugin.enableForWorkspaceTypeScriptVersions) {
            pluginPaths.push(plugin.path);
          }
        }
      }
      if (pluginPaths.length) {
        args.push("--pluginProbeLocations", pluginPaths.join(","));
      }
    }
    if (this._configuration.locale) {
      args.push("--locale", this._configuration.locale);
    }
    if (this._configuration.typingsCacheLocation) {
      args.push("--globalTypingsCacheLocation", `"${this._configuration.typingsCacheLocation}"`);
    }
    if (this.apiVersion.gte(api_default.v234)) {
      let {npmLocation} = this._configuration;
      if (npmLocation) {
        this.logger.info(`using npm from ${npmLocation}`);
        args.push("--npmLocation", `"${npmLocation}"`);
      }
    }
    if (this.apiVersion.gte(api_default.v291)) {
      args.push("--noGetErrOnBackgroundUpdate");
    }
    if (this.apiVersion.gte(api_default.v345)) {
      args.push("--validateDefaultNpmLocation");
    }
    return args;
  }
  getProjectRootPath(uri) {
    let root = import_coc28.workspace.cwd;
    let u = import_coc28.Uri.parse(uri);
    if (u.scheme !== "file")
      return void 0;
    let folder = import_coc28.workspace.getWorkspaceFolder(uri);
    if (folder) {
      root = import_coc28.Uri.parse(folder.uri).fsPath;
    } else {
      let filepath = import_coc28.Uri.parse(uri).fsPath;
      if (!filepath.startsWith(root)) {
        root = import_path7.default.dirname(filepath);
      }
    }
    if (root == import_os2.default.homedir())
      return void 0;
    return root;
  }
  configurePlugin(pluginName, configuration) {
    if (this.apiVersion.gte(api_default.v314)) {
      if (!this.servicePromise)
        return;
      this.servicePromise.then(() => {
        this.executeWithoutWaitingForResponse("configurePlugin", {pluginName, configuration});
      });
    }
  }
  interruptGetErr(f) {
    return this.bufferSyncSupport.interuptGetErr(f);
  }
  cancelInflightRequestsForResource(resource) {
    if (this.state !== import_coc28.ServiceStat.Running || !this.tsServerProcess) {
      return;
    }
    for (const request of this.tsServerProcess.toCancelOnResourceChange) {
      if (request.resource.toString() === resource.toString()) {
        request.cancel();
      }
    }
  }
};
var typescriptServiceClient_default = TypeScriptServiceClient;
function getDiagnosticsKind(event) {
  switch (event.event) {
    case "syntaxDiag":
      return DiagnosticKind.Syntax;
    case "semanticDiag":
      return DiagnosticKind.Semantic;
    case "suggestionDiag":
      return DiagnosticKind.Suggestion;
  }
  throw new Error("Unknown dignostics kind");
}
var fenceCommands = new Set(["change", "close", "open"]);
function getQueueingType(command, lowPriority) {
  if (fenceCommands.has(command)) {
    return RequestQueueingType.Fence;
  }
  return lowPriority ? RequestQueueingType.LowPriority : RequestQueueingType.Normal;
}

// src/server/utils/languageDescription.ts
var DiagnosticLanguage;
(function(DiagnosticLanguage2) {
  DiagnosticLanguage2[DiagnosticLanguage2["JavaScript"] = 0] = "JavaScript";
  DiagnosticLanguage2[DiagnosticLanguage2["TypeScript"] = 1] = "TypeScript";
})(DiagnosticLanguage || (DiagnosticLanguage = {}));
var standardLanguageDescriptions = [
  {
    id: "typescript",
    diagnosticSource: "ts",
    diagnosticOwner: "typescript",
    modeIds: [
      typescript,
      typescriptreact,
      typescripttsx,
      typescriptjsx
    ],
    diagnosticLanguage: 1,
    configFile: "tsconfig.json",
    configFilePattern: /^tsconfig(\..*)?\.json$/gi
  },
  {
    id: "javascript",
    diagnosticSource: "ts",
    diagnosticOwner: "typescript",
    modeIds: [javascript, javascriptreact, javascriptjsx],
    diagnosticLanguage: 0,
    configFile: "jsconfig.json",
    configFilePattern: /^jsconfig(\..*)?\.json$/gi
  }
];

// src/server/utils/typingsStatus.ts
var import_coc29 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol21 = __toModule(require_main3());
var typingsInstallTimeout = 30 * 1e3;
var TypingsStatus = class {
  constructor(client) {
    this._acquiringTypings = Object.create({});
    this._subscriptions = [];
    this._client = client;
    this._subscriptions.push(this._client.onDidBeginInstallTypings((event) => this.onBeginInstallTypings(event.eventId)));
    this._subscriptions.push(this._client.onDidEndInstallTypings((event) => this.onEndInstallTypings(event.eventId)));
  }
  dispose() {
    this._subscriptions.forEach((x) => x.dispose());
    for (const eventId of Object.keys(this._acquiringTypings)) {
      clearTimeout(this._acquiringTypings[eventId]);
    }
  }
  get isAcquiringTypings() {
    return Object.keys(this._acquiringTypings).length > 0;
  }
  onBeginInstallTypings(eventId) {
    if (this._acquiringTypings[eventId]) {
      return;
    }
    this._acquiringTypings[eventId] = setTimeout(() => {
      this.onEndInstallTypings(eventId);
    }, typingsInstallTimeout);
  }
  onEndInstallTypings(eventId) {
    const timer = this._acquiringTypings[eventId];
    if (timer) {
      clearTimeout(timer);
    }
    delete this._acquiringTypings[eventId];
  }
};
var typingsStatus_default = TypingsStatus;
var AtaProgressReporter = class {
  constructor(client) {
    this._promises = new Map();
    this._invalid = false;
    this.statusItem = import_coc29.window.createStatusBarItem(10, {progress: true});
    const disposables = [];
    disposables.push(client.onDidBeginInstallTypings((e) => this._onBegin(e.eventId)));
    disposables.push(client.onDidEndInstallTypings((e) => this._onEndOrTimeout(e.eventId)));
    disposables.push(client.onTypesInstallerInitializationFailed((_) => this.onTypesInstallerInitializationFailed()));
    this._disposable = import_vscode_languageserver_protocol21.Disposable.create(() => {
      disposables.forEach((disposable) => {
        disposable.dispose();
      });
    });
  }
  dispose() {
    this._disposable.dispose();
    this._promises.forEach((value) => value());
  }
  _onBegin(eventId) {
    const handle = setTimeout(() => this._onEndOrTimeout(eventId), typingsInstallTimeout);
    new Promise((resolve) => {
      this._promises.set(eventId, () => {
        clearTimeout(handle);
        resolve();
      });
    });
    this.statusItem.text = "Fetching data for better TypeScript IntelliSense";
    this.statusItem.show();
  }
  _onEndOrTimeout(eventId) {
    this.statusItem.hide();
    const resolve = this._promises.get(eventId);
    if (resolve) {
      this._promises.delete(eventId);
      resolve();
    }
  }
  onTypesInstallerInitializationFailed() {
    this.statusItem.hide();
    if (!this._invalid) {
      import_coc29.window.showMessage("Could not install typings files for JavaScript language features. Please ensure that NPM is installed", "error");
    }
    this._invalid = true;
  }
};

// src/server/typescriptServiceClientHost.ts
var styleCheckDiagnostics = [
  6133,
  6138,
  7027,
  7028,
  7029,
  7030
];
var TypeScriptServiceClientHost = class {
  constructor(descriptions, pluginManager) {
    this.languagePerId = new Map();
    this.disposables = [];
    this.reportStyleCheckAsWarnings = true;
    let timer;
    const handleProjectChange = () => {
      if (timer)
        clearTimeout(timer);
      timer = setTimeout(() => {
        this.triggerAllDiagnostics();
      }, 1500);
    };
    const configFileWatcher = import_coc30.workspace.createFileSystemWatcher("**/[tj]sconfig.json");
    this.disposables.push(configFileWatcher);
    configFileWatcher.onDidCreate(this.reloadProjects, this, this.disposables);
    configFileWatcher.onDidDelete(this.reloadProjects, this, this.disposables);
    configFileWatcher.onDidChange(handleProjectChange, this, this.disposables);
    const packageFileWatcher = import_coc30.workspace.createFileSystemWatcher("**/package.json");
    packageFileWatcher.onDidCreate(this.reloadProjects, this, this.disposables);
    packageFileWatcher.onDidChange(handleProjectChange, this, this.disposables);
    const allModeIds = this.getAllModeIds(descriptions, pluginManager);
    this.client = new typescriptServiceClient_default(pluginManager, allModeIds);
    this.disposables.push(this.client);
    this.client.onDiagnosticsReceived(({kind, resource, diagnostics}) => {
      this.diagnosticsReceived(kind, resource, diagnostics).catch((e) => {
        console.error(e);
      });
    }, null, this.disposables);
    this.disposables.push(new watchBuild_default(this.client));
    this.disposables.push(import_coc30.languages.registerWorkspaceSymbolProvider(new workspaceSymbols_default(this.client, allModeIds)));
    this.client.onConfigDiagnosticsReceived((diag) => {
      let {body} = diag;
      if (body) {
        let {configFile, diagnostics} = body;
        let uri = import_coc30.Uri.file(configFile);
        if (diagnostics.length == 0) {
          this.client.diagnosticsManager.configFileDiagnosticsReceived(uri.toString(), []);
        } else {
          let diagnosticList = diagnostics.map((o) => {
            let {text, code, category, start, end} = o;
            let range;
            if (!start || !end) {
              range = import_vscode_languageserver_protocol22.Range.create(import_vscode_languageserver_protocol22.Position.create(0, 0), import_vscode_languageserver_protocol22.Position.create(0, 1));
            } else {
              range = import_vscode_languageserver_protocol22.Range.create(start.line - 1, start.offset - 1, end.line - 1, end.offset - 1);
            }
            let severity = category == "error" ? import_vscode_languageserver_protocol22.DiagnosticSeverity.Error : import_vscode_languageserver_protocol22.DiagnosticSeverity.Warning;
            return import_vscode_languageserver_protocol22.Diagnostic.create(range, text, severity, code);
          });
          this.client.diagnosticsManager.configFileDiagnosticsReceived(uri.toString(), diagnosticList);
        }
      }
    }, null, this.disposables);
    this.typingsStatus = new typingsStatus_default(this.client);
    this.ataProgressReporter = new AtaProgressReporter(this.client);
    this.fileConfigurationManager = new fileConfigurationManager_default(this.client);
    for (const description of descriptions) {
      const manager = new languageProvider_default(this.client, this.fileConfigurationManager, description, this.typingsStatus);
      this.languagePerId.set(description.id, manager);
    }
    const languageIds = new Set();
    for (const plugin of pluginManager.plugins) {
      if (plugin.configNamespace && plugin.languages.length) {
        this.registerExtensionLanguageProvider({
          id: plugin.configNamespace,
          modeIds: Array.from(plugin.languages),
          diagnosticSource: "ts-plugin",
          diagnosticLanguage: DiagnosticLanguage.TypeScript,
          diagnosticOwner: "typescript",
          isExternal: true
        });
      } else {
        for (const language of plugin.languages) {
          languageIds.add(language);
        }
      }
    }
    if (languageIds.size) {
      this.registerExtensionLanguageProvider({
        id: "typescript-plugins",
        modeIds: Array.from(languageIds.values()),
        diagnosticSource: "ts-plugin",
        diagnosticLanguage: DiagnosticLanguage.TypeScript,
        diagnosticOwner: "typescript",
        isExternal: true
      });
    }
    this.client.ensureServiceStarted();
    this.client.onTsServerStarted(() => {
      this.triggerAllDiagnostics();
    });
    import_coc30.workspace.onDidChangeConfiguration(this.configurationChanged, this, this.disposables);
    this.configurationChanged();
  }
  registerExtensionLanguageProvider(description) {
    const manager = new languageProvider_default(this.client, this.fileConfigurationManager, description, this.typingsStatus);
    this.languagePerId.set(description.id, manager);
  }
  dispose() {
    import_coc30.disposeAll(this.disposables);
    for (let language of this.languagePerId.values()) {
      language.dispose();
    }
    this.languagePerId.clear();
    this.fileConfigurationManager.dispose();
    this.typingsStatus.dispose();
    this.ataProgressReporter.dispose();
  }
  reset() {
    this.fileConfigurationManager.reset();
  }
  get serviceClient() {
    return this.client;
  }
  reloadProjects() {
    this.client.diagnosticsManager.reInitialize();
    this.client.execute("reloadProjects", null, import_vscode_languageserver_protocol22.CancellationToken.None);
    this.triggerAllDiagnostics();
  }
  getProvider(languageId) {
    return this.languagePerId.get(languageId);
  }
  configurationChanged() {
    const config = import_coc30.workspace.getConfiguration("tsserver");
    this.reportStyleCheckAsWarnings = config.get("reportStyleChecksAsWarnings", true);
  }
  async findLanguage(uri) {
    try {
      let doc = this.client.getDocument(uri);
      if (!doc)
        return void 0;
      let languages4 = Array.from(this.languagePerId.values());
      return languages4.find((language) => language.handles(uri, doc.textDocument));
    } catch {
      return void 0;
    }
  }
  async handles(doc) {
    let languages4 = Array.from(this.languagePerId.values());
    let idx = languages4.findIndex((language) => language.handles(doc.uri, doc));
    if (idx != -1)
      return true;
    return this.client.bufferSyncSupport.handles(doc.uri);
  }
  triggerAllDiagnostics() {
    for (const language of this.languagePerId.values()) {
      language.triggerAllDiagnostics();
    }
  }
  async diagnosticsReceived(kind, resource, diagnostics) {
    const language = await this.findLanguage(resource.toString());
    if (language) {
      language.diagnosticsReceived(kind, resource, this.createMarkerDatas(diagnostics));
    }
  }
  createMarkerDatas(diagnostics) {
    return diagnostics.map((tsDiag) => this.tsDiagnosticToLspDiagnostic(tsDiag));
  }
  tsDiagnosticToLspDiagnostic(diagnostic) {
    const {start, end, text} = diagnostic;
    const range = {
      start: Position.fromLocation(start),
      end: Position.fromLocation(end)
    };
    let relatedInformation;
    if (diagnostic.relatedInformation) {
      relatedInformation = diagnostic.relatedInformation.map((o) => {
        let {span, message} = o;
        return {
          location: Location2.fromTextSpan(this.client.toResource(span.file), span),
          message
        };
      });
    }
    return {
      range,
      message: text,
      code: diagnostic.code ? diagnostic.code : null,
      severity: this.getDiagnosticSeverity(diagnostic),
      reportUnnecessary: diagnostic.reportsUnnecessary,
      source: diagnostic.source || "tsserver",
      relatedInformation
    };
  }
  getDiagnosticSeverity(diagnostic) {
    if (this.reportStyleCheckAsWarnings && this.isStyleCheckDiagnostic(diagnostic.code) && diagnostic.category === DiagnosticCategory.error) {
      return import_vscode_languageserver_protocol22.DiagnosticSeverity.Warning;
    }
    switch (diagnostic.category) {
      case DiagnosticCategory.error:
        return import_vscode_languageserver_protocol22.DiagnosticSeverity.Error;
      case DiagnosticCategory.warning:
        return import_vscode_languageserver_protocol22.DiagnosticSeverity.Warning;
      case DiagnosticCategory.suggestion:
        return import_vscode_languageserver_protocol22.DiagnosticSeverity.Information;
      default:
        return import_vscode_languageserver_protocol22.DiagnosticSeverity.Error;
    }
  }
  isStyleCheckDiagnostic(code) {
    return code ? styleCheckDiagnostics.indexOf(code) !== -1 : false;
  }
  getAllModeIds(descriptions, pluginManager) {
    const allModeIds = flatten([
      ...descriptions.map((x) => x.modeIds),
      ...pluginManager.plugins.map((x) => x.languages)
    ]);
    return allModeIds;
  }
};
var typescriptServiceClientHost_default = TypeScriptServiceClientHost;

// src/server/index.ts
var TsserverService = class {
  constructor(pluginManager) {
    this.pluginManager = pluginManager;
    this.id = "tsserver";
    this.name = "tsserver";
    this.state = import_coc31.ServiceStat.Initial;
    this._onDidServiceReady = new import_vscode_languageserver_protocol23.Emitter();
    this.onServiceReady = this._onDidServiceReady.event;
    this.disposables = [];
    this.descriptions = [];
    const config = import_coc31.workspace.getConfiguration("tsserver");
    const enableJavascript = !!config.get("enableJavascript");
    this.enable = config.get("enable");
    this.descriptions = standardLanguageDescriptions.filter((o) => {
      return enableJavascript ? true : o.id != "javascript";
    });
    this.selector = this.descriptions.reduce((arr, c) => {
      return arr.concat(c.modeIds);
    }, []);
  }
  get config() {
    return import_coc31.workspace.getConfiguration("tsserver");
  }
  getClientHost() {
    if (this.state == import_coc31.ServiceStat.Running)
      return Promise.resolve(this.clientHost);
    this.start();
    return new Promise((resolve, reject) => {
      let timer = setTimeout(() => {
        reject(new Error(`Server not started after 5s`));
      }, 5e3);
      let disposable = this.onServiceReady(() => {
        clearTimeout(timer);
        disposable.dispose();
        resolve(this.clientHost);
      });
    });
  }
  start() {
    if (this.clientHost)
      return;
    this.state = import_coc31.ServiceStat.Starting;
    this.clientHost = new typescriptServiceClientHost_default(this.descriptions, this.pluginManager);
    this.disposables.push(this.clientHost);
    let client = this.clientHost.serviceClient;
    return new Promise((resolve) => {
      let started = false;
      client.onTsServerStarted(() => {
        Object.defineProperty(this, "state", {
          get: () => {
            return this.clientHost.serviceClient.state;
          }
        });
        this._onDidServiceReady.fire(void 0);
        if (!started) {
          started = true;
          resolve();
        }
      });
    });
  }
  dispose() {
    import_coc31.disposeAll(this.disposables);
  }
  async restart() {
    if (!this.clientHost)
      return;
    let client = this.clientHost.serviceClient;
    await client.restartTsServer();
  }
  async stop() {
    if (!this.clientHost)
      return;
    this.clientHost.reset();
    let client = this.clientHost.serviceClient;
    await client.stop();
    return;
  }
};
var server_default = TsserverService;

// src/utils/plugins.ts
var import_coc32 = __toModule(require("coc.nvim"));
var import_vscode_languageserver_protocol24 = __toModule(require_main3());
var TypeScriptServerPlugin;
(function(TypeScriptServerPlugin2) {
  function equals2(a, b) {
    return a.path === b.path && a.name === b.name && a.enableForWorkspaceTypeScriptVersions === b.enableForWorkspaceTypeScriptVersions && equals(a.languages, b.languages);
  }
  TypeScriptServerPlugin2.equals = equals2;
})(TypeScriptServerPlugin || (TypeScriptServerPlugin = {}));
var PluginManager = class {
  constructor() {
    this._pluginConfigurations = new Map();
    this._disposables = [];
    this._onDidUpdatePlugins = this._register(new import_vscode_languageserver_protocol24.Emitter());
    this.onDidChangePlugins = this._onDidUpdatePlugins.event;
    this._onDidUpdateConfig = this._register(new import_vscode_languageserver_protocol24.Emitter());
    this.onDidUpdateConfig = this._onDidUpdateConfig.event;
    let loadPlugins = () => {
      if (!this._plugins) {
        return;
      }
      const newPlugins = this.readPlugins();
      if (!equals(flatten(Array.from(this._plugins.values())), flatten(Array.from(newPlugins.values())), TypeScriptServerPlugin.equals)) {
        this._plugins = newPlugins;
        this._onDidUpdatePlugins.fire(this);
      }
    };
    import_coc32.extensions.onDidActiveExtension(loadPlugins, void 0, this._disposables);
    import_coc32.extensions.onDidUnloadExtension(loadPlugins, void 0, this._disposables);
  }
  dispose() {
    import_coc32.disposeAll(this._disposables);
  }
  get plugins() {
    if (!this._plugins) {
      this._plugins = this.readPlugins();
    }
    return flatten(Array.from(this._plugins.values()));
  }
  _register(value) {
    this._disposables.push(value);
    return value;
  }
  setConfiguration(pluginId, config) {
    this._pluginConfigurations.set(pluginId, config);
    this._onDidUpdateConfig.fire({pluginId, config});
  }
  configurations() {
    return this._pluginConfigurations.entries();
  }
  readPlugins() {
    const pluginMap = new Map();
    for (const extension of import_coc32.extensions.all) {
      const pack = extension.packageJSON;
      if (pack.contributes && Array.isArray(pack.contributes.typescriptServerPlugins)) {
        const plugins = [];
        for (const plugin of pack.contributes.typescriptServerPlugins) {
          plugins.push({
            name: plugin.name,
            enableForWorkspaceTypeScriptVersions: !!plugin.enableForWorkspaceTypeScriptVersions,
            path: extension.extensionPath,
            languages: Array.isArray(plugin.languages) ? plugin.languages : []
          });
        }
        if (plugins.length) {
          pluginMap.set(extension.id, plugins);
        }
      }
    }
    return pluginMap;
  }
};

// src/index.ts
async function activate(context) {
  let {subscriptions, logger} = context;
  const config = import_coc33.workspace.getConfiguration().get("tsserver", {});
  if (!config.enable)
    return;
  const pluginManager = new PluginManager();
  const service = new server_default(pluginManager);
  function registCommand2(cmd) {
    let {id, execute} = cmd;
    subscriptions.push(import_coc33.commands.registerCommand(id, execute, cmd));
  }
  registCommand2(new ConfigurePluginCommand(pluginManager));
  registCommand2(new AutoFixCommand(service));
  registCommand2(new ReloadProjectsCommand(service));
  registCommand2(new OpenTsServerLogCommand(service));
  registCommand2(new TypeScriptGoToProjectConfigCommand(service));
  registCommand2(new OrganizeImportsCommand(service));
  registCommand2({
    id: "tsserver.restart",
    execute: () => {
      service.stop().then(() => {
        setTimeout(() => {
          service.restart();
        }, 100);
      });
    }
  });
  service.start().then(() => {
    subscriptions.push(import_coc33.services.regist(service));
  }, (e) => {
    logger.error(`Error on service start:`, e);
  });
  return {
    configurePlugin: (pluginId, configuration) => {
      pluginManager.setConfiguration(pluginId, configuration);
    }
  };
}
//# sourceMappingURL=index.js.map
